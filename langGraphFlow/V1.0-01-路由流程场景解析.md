# LangGraph路由流程场景解析

## 文档说明

本文档解答多智能体路由系统中三种实际场景的业务表现和技术原理：
1. 正常情况：患者在专门智能体中完成业务处理
2. 异常情况：患者进入专门智能体后没有回复
3. 用户离开：患者离开后第二天回来继续对话

---

## 一、核心机制理解

### 1.1 LangGraph的工作机制

LangGraph的核心特点是**状态保持**和**自动恢复**：

1. **状态保存**：每次Agent执行后，会自动将对话状态保存到checkpointer（PostgreSQL）
2. **状态恢复**：下次调用时，通过`thread_id`自动恢复之前的对话历史
3. **消息累积**：对话历史会不断累积，形成完整的上下文

### 1.2 关键配置参数

```python
# 每次调用Agent时，都会传入相同的thread_id
config = {"configurable": {"thread_id": session_id}}

# LangGraph会自动：
# 1. 从checkpointer中读取该thread_id的历史对话
# 2. 将新消息追加到历史对话后面
# 3. 执行Agent逻辑
# 4. 保存新的对话状态
result = await agent.ainvoke(
    {"messages": [{"role": "user", "content": new_query}]},
    config=config
)
```

### 1.3 路由图的执行流程

```
用户请求 → FastAPI接口 → Agent.ainvoke()
    ↓
读取历史对话（从checkpointer）
    ↓
判断当前状态（如果有路由图）
    ↓
执行对应的节点逻辑
    ↓
保存新的对话状态（到checkpointer）
    ↓
返回结果
```

**重要**：LangGraph**不是**每次都从头开始执行路由图，而是：
- 如果对话历史中有未完成的流程，会继续执行
- 如果对话历史已完成，会根据新消息重新判断

---

## 二、场景一：正常情况 - 患者完成业务处理

### 2.1 业务流程示例

**对话流程**：
```
用户: "我想记录血压"
Agent: [路由到血压记录智能体] "请告诉我您的收缩压是多少？"
用户: "120"
Agent: "好的，请告诉我您的舒张压是多少？"
用户: "80"
Agent: "请问您是什么时候测量的？"
用户: "今天早上8点"
Agent: [调用record_blood_pressure工具] "成功保存血压记录..."
```

### 2.2 实际表现

1. **第一次请求**（"我想记录血压"）
   - 路由智能体识别意图 → `blood_pressure`
   - 路由到血压记录智能体
   - 血压记录智能体开始引导流程
   - 保存状态：当前在血压记录智能体中，等待用户提供收缩压

2. **第二次请求**（"120"）
   - 恢复历史对话：知道当前在血压记录智能体中，正在收集收缩压
   - 血压记录智能体接收收缩压值，继续询问舒张压
   - 保存状态：已收集收缩压=120，等待舒张压

3. **第三次请求**（"80"）
   - 恢复历史对话：知道已收集收缩压=120，正在收集舒张压
   - 血压记录智能体接收舒张压值，继续询问时间
   - 保存状态：已收集收缩压=120，舒张压=80，等待时间

4. **第四次请求**（"今天早上8点"）
   - 恢复历史对话：知道已收集所有必要信息
   - 血压记录智能体调用工具保存数据
   - 保存状态：任务完成

### 2.3 技术原理

**对话历史在PostgreSQL中的存储**（简化示例）：

```json
{
  "thread_id": "session_123",
  "messages": [
    {"role": "system", "content": "..."},
    {"role": "user", "content": "我想记录血压"},
    {"role": "assistant", "content": "请告诉我您的收缩压是多少？"},
    {"role": "user", "content": "120"},
    {"role": "assistant", "content": "好的，请告诉我您的舒张压是多少？"},
    {"role": "user", "content": "80"},
    {"role": "assistant", "content": "请问您是什么时候测量的？"},
    {"role": "user", "content": "今天早上8点"},
    {"role": "assistant", "content": "成功保存血压记录..."}
  ]
}
```

**每次调用时的处理**：
```python
# 第1次调用
agent.ainvoke(
    {"messages": [{"role": "user", "content": "我想记录血压"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer中：空 → 保存1条消息

# 第2次调用
agent.ainvoke(
    {"messages": [{"role": "user", "content": "120"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer中：读取之前的所有消息 → 追加新消息 → 保存完整历史

# 第3次调用
agent.ainvoke(
    {"messages": [{"role": "user", "content": "80"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer中：读取之前的所有消息 → 追加新消息 → 保存完整历史

# ... 以此类推
```

**关键点**：
- LangGraph会自动从checkpointer读取历史对话
- 新消息会追加到历史对话后面
- LLM基于完整的历史对话生成回复
- 每次执行后都会保存完整的历史对话

---

## 三、场景二：异常情况 - 患者没有回复

### 3.1 业务流程示例

**对话流程**：
```
用户: "我想记录血压"
Agent: [路由到血压记录智能体] "请告诉我您的收缩压是多少？"
用户: [没有回复，或者回复了无关内容]
```

### 3.2 实际表现分析

#### 情况A：用户完全没有回复（超时）

**实际表现**：
- Agent在等待用户回复，没有新的执行
- 对话状态保存在checkpointer中，状态为：等待用户提供收缩压
- 如果用户一直不回复，对话会保持在这个状态

**技术原理**：
```
时间点1: 用户发送"我想记录血压"
  → Agent执行，保存状态：等待收缩压
  → checkpointer中保存完整的对话历史

时间点2: 用户没有回复（1小时后）
  → 没有新的Agent执行
  → checkpointer中的状态保持不变
  → 如果配置了TTL，Redis中的会话状态可能过期，但PostgreSQL中的checkpoint不会过期

时间点3: 用户回复（无论多久后）
  → Agent读取checkpointer中的历史对话
  → 继续之前的流程
```

#### 情况B：用户回复了无关内容

**实际表现**（取决于LLM的智能程度）：

**示例1：LLM理解上下文，引导用户**
```
用户: "我想记录血压"
Agent: "请告诉我您的收缩压是多少？"
用户: "今天天气真好"
Agent: "我理解您的话题，但我们现在正在记录血压数据。请告诉我您的收缩压是多少？"
```

**示例2：LLM理解用户改变了意图**
```
用户: "我想记录血压"
Agent: "请告诉我您的收缩压是多少？"
用户: "算了，我想预约复诊"
Agent: [重新路由到复诊智能体]（需要实现路由检查机制）
```

**注意**：重新路由的实现取决于具体的架构方案，详见 `V1.0-02-重新路由技术细节.md`。

**技术原理**：
```python
# 用户发送无关消息时
agent.ainvoke(
    {"messages": [{"role": "user", "content": "今天天气真好"}]},
    config={"configurable": {"thread_id": "session_123"}}
)

# LangGraph的处理流程：
# 1. 从checkpointer读取历史对话
#    - 之前：用户说"我想记录血压"，Agent说"请告诉我您的收缩压是多少？"
# 2. 追加新消息
#    - 现在：用户说"今天天气真好"
# 3. LLM基于完整上下文生成回复
#    - LLM看到：之前在收集血压数据，现在用户说了无关内容
#    - LLM决策：提醒用户继续完成血压记录，或者理解用户改变了意图
```

**LLM的处理策略**（由系统提示词指导）：
- 如果提示词强调"不要偏离当前任务"，LLM会引导用户回到原任务
- 如果提示词强调"理解用户意图变化"，LLM可能会重新路由

### 3.3 优化建议

**针对"用户没有回复"的情况**：

1. **超时提醒机制**
   ```python
   # 可以在后端添加定时任务
   # 检查长时间未活跃的会话，发送提醒
   async def check_inactive_sessions():
       # 查询超过30分钟未更新的会话
       inactive_sessions = await get_inactive_sessions(minutes=30)
       for session in inactive_sessions:
           # 发送提醒消息
           await send_reminder(session.user_id, "您还在记录血压吗？")
   ```

2. **上下文清理机制**
   ```python
   # 如果用户长时间没有回复，可以清理上下文
   # 或者添加一个"重新开始"的机制
   if user_says_restart():
       # 清除checkpointer中的历史
       await checkpointer.delete({"thread_id": session_id})
   ```

3. **系统提示词优化**
   ```python
   system_message = """
   如果用户偏离了当前任务，请友好地提醒用户：
   - "我们正在记录血压数据，请继续完成..."
   - "如果您想切换任务，请告诉我..."
   
   如果用户明确改变了意图，请重新路由到对应的智能体。
   """
   ```

---

## 四、场景三：用户离开 - 第二天回来继续对话

### 4.1 业务流程示例

**第一天**：
```
用户: "我想记录血压"
Agent: "请告诉我您的收缩压是多少？"
用户: "120"
Agent: "好的，请告诉我您的舒张压是多少？"
用户: [离开，没有回复]
```

**第二天**：
```
用户: "80"
Agent: [继续之前的流程] "请问您是什么时候测量的？"
```

### 4.2 实际表现

#### 情况A：用户继续之前的任务

**实际表现**：
```
第二天，用户说："80"
Agent会自动：
1. 从checkpointer读取昨天的对话历史
2. 理解上下文：昨天在收集血压数据，已收集收缩压=120，现在用户提供舒张压=80
3. 继续引导流程：询问测量时间
```

**技术原理**：

```python
# 第一天：用户发送"我想记录血压"
agent.ainvoke(
    {"messages": [{"role": "user", "content": "我想记录血压"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer保存：等待收缩压

# 第一天：用户发送"120"
agent.ainvoke(
    {"messages": [{"role": "user", "content": "120"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer保存：收缩压=120，等待舒张压

# 第二天：用户发送"80"
agent.ainvoke(
    {"messages": [{"role": "user", "content": "80"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer读取：昨天的所有历史对话
# LLM看到：昨天在收集血压数据，已收集收缩压=120，现在用户提供80
# LLM理解：80是舒张压，继续询问时间
```

**关键点**：
- ✅ **PostgreSQL的checkpoint是持久化的**，不会因为时间过期而丢失
- ✅ **LangGraph会自动恢复历史对话**，无需手动处理
- ✅ **LLM基于完整上下文理解**，知道当前处于哪个流程

#### 情况B：用户改变了意图

**实际表现**：
```
第二天，用户说："算了，我想预约复诊"
Agent会：
1. 从checkpointer读取昨天的对话历史
2. 理解用户改变了意图
3. 重新路由到复诊智能体
4. 开始复诊预约流程
```

**技术原理**：

```python
# 第二天：用户发送"算了，我想预约复诊"
agent.ainvoke(
    {"messages": [{"role": "user", "content": "算了，我想预约复诊"}]},
    config={"configurable": {"thread_id": "session_123"}}
)

# LangGraph的处理：
# 1. 读取历史对话（昨天的血压记录对话）
# 2. 路由智能体识别意图：复诊预约
# 3. 路由到复诊智能体
# 4. 复诊智能体开始新的流程（不依赖之前的血压记录流程）
```

**关键点**：
- LLM能够理解上下文中的意图变化
- **重新路由需要实现路由检查机制**（详见 `V1.0-02-重新路由技术细节.md`）
- 如果使用StateGraph方案，可以实现自动重新路由
- 如果使用独立Agent方案，需要在API层实现路由检查
- 之前未完成的流程可以被"覆盖"或"暂停"

### 4.3 时间相关的问题

#### 问题1：checkpoint会过期吗？

**答案**：**不会**

- **PostgreSQL的checkpoint是持久化的**，只要数据库不删除，checkpoint就一直存在
- **Redis的会话状态可能过期**（根据TTL配置），但checkpoint不受影响
- **即使Redis会话过期，checkpoint仍然可以恢复**

**示例**：
```python
# 第一天：创建会话
session_id = "session_123"
await session_manager.create_session(user_id, session_id, ttl=3600)  # Redis TTL=1小时

# 第二天：Redis会话可能已过期，但checkpoint还在
# 如果用户再次使用相同的session_id，可以恢复对话
agent.ainvoke(
    {"messages": [{"role": "user", "content": "继续"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# LangGraph会自动从checkpoint恢复历史对话
```

#### 问题2：如何处理"昨天"、"今天"等时间概念？

**答案**：需要在系统提示词中说明

```python
system_message = """
当前日期时间：{current_datetime}

当用户提到"昨天"、"今天"、"明天"等时间概念时：
- 请根据当前日期时间计算具体日期
- 例如：如果今天是2025-11-05，用户说"昨天"，指的是2025-11-04
"""
```

#### 问题3：如果用户忘记了之前的对话怎么办？

**答案**：可以添加"查看历史"功能

```python
@tool("view_conversation_history", description="查看当前对话的历史记录")
async def view_conversation_history() -> str:
    """
    返回当前对话的历史记录
    """
    # 从checkpointer读取历史对话
    # 格式化返回给用户
    pass
```

### 4.4 实际代码示例

**检查checkpoint是否存在**：

```python
from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver

async def check_session_exists(session_id: str, checkpointer: AsyncPostgresSaver) -> bool:
    """检查会话是否存在checkpoint"""
    try:
        # 尝试读取checkpoint
        checkpoint = await checkpointer.aget(
            {"configurable": {"thread_id": session_id}}
        )
        return checkpoint is not None
    except Exception:
        return False

async def get_conversation_history(session_id: str, checkpointer: AsyncPostgresSaver) -> List[dict]:
    """获取对话历史"""
    try:
        checkpoint = await checkpointer.aget(
            {"configurable": {"thread_id": session_id}}
        )
        if checkpoint:
            # 从checkpoint中提取messages
            messages = checkpoint.get("channel_values", {}).get("messages", [])
            return [{"role": msg.type, "content": msg.content} for msg in messages]
        return []
    except Exception:
        return []
```

**在API中使用**：

```python
@app.post("/agent/invoke", response_model=AgentResponse)
async def invoke_agent(request: AgentRequest):
    session_id = request.session_id
    
    # 检查是否有历史对话
    has_history = await check_session_exists(session_id, app.state.checkpointer)
    
    if has_history:
        logger.info(f"会话 {session_id} 有历史对话，将恢复上下文")
        # LangGraph会自动恢复，无需手动处理
    else:
        logger.info(f"会话 {session_id} 是新会话")
    
    # 调用Agent（LangGraph会自动处理历史恢复）
    result = await agent.ainvoke(
        {"messages": [{"role": "user", "content": request.query}]},
        config={"configurable": {"thread_id": session_id}}
    )
    
    return await process_agent_result(session_id, result, request.user_id)
```

---

## 五、技术原理总结

### 5.1 LangGraph的状态管理机制

1. **Checkpointer（短期记忆）**
   - 存储在PostgreSQL中
   - 以`thread_id`为键，保存完整的对话历史
   - 持久化存储，不会过期
   - 每次Agent执行后自动保存

2. **消息累积机制**
   - 新消息会追加到历史消息后面
   - LLM基于完整的历史上下文生成回复
   - 支持多轮对话的连续性

3. **自动恢复机制**
   - 每次调用时，自动从checkpointer读取历史
   - 无需手动管理对话历史
   - 支持跨时间段的对话恢复

### 5.2 路由图的执行逻辑

**重要理解**：路由图不是每次都从头执行

1. **首次调用**：从路由智能体开始，识别意图，路由到专门智能体
2. **后续调用**：
   - 如果对话历史中有未完成的流程，继续执行该流程
   - 如果对话历史已完成，根据新消息重新判断意图
   - 如果用户改变了意图，可以重新路由

**示例**：
```python
# 第1次调用：路由到血压记录智能体
# 状态：在血压记录智能体中，等待收缩压

# 第2次调用：检查状态，发现在血压记录智能体中
# 继续执行血压记录智能体的流程

# 第3次调用：用户说"我想预约复诊"
# 路由智能体识别新意图，重新路由到复诊智能体
```

### 5.3 异常情况的处理策略

1. **用户没有回复**
   - 对话状态保存在checkpoint中
   - 用户回来后可以继续对话
   - 可以添加超时提醒机制

2. **用户回复无关内容**
   - LLM基于上下文理解用户意图
   - 可以引导用户回到原任务
   - 也可以理解用户改变了意图

3. **用户离开后回来**
   - checkpoint持久化保存，不会丢失
   - 自动恢复历史对话
   - 支持跨时间段的对话

---

## 六、最佳实践建议

### 6.1 会话管理

1. **使用稳定的session_id**
   ```python
   # 推荐：使用用户ID + 时间戳生成稳定的session_id
   session_id = f"{user_id}_{datetime.now().strftime('%Y%m%d')}"
   
   # 或者：使用UUID，但需要用户记住session_id
   session_id = str(uuid.uuid4())
   ```

2. **检查会话状态**
   ```python
   # 在调用Agent前，检查会话状态
   session = await session_manager.get_session(user_id, session_id)
   if session and session.get("status") == "completed":
       # 可以提示用户是否继续之前的对话
       pass
   ```

### 6.2 上下文管理

1. **清理过长的上下文**
   ```python
   # 使用trimmed_messages_hook自动清理
   def trimmed_messages_hook(state):
       trimmed_messages = trim_messages(
           messages=state["messages"],
           max_tokens=2000,
           strategy="last",
           start_on="human"
       )
       return {"messages": trimmed_messages}
   ```

2. **添加对话总结功能**
   ```python
   @tool("summarize_conversation", description="总结当前对话")
   async def summarize_conversation() -> str:
       """将当前对话总结为简短描述"""
       # 调用LLM总结对话
       pass
   ```

### 6.3 用户体验优化

1. **添加进度提示**
   ```python
   # 在系统提示词中说明当前进度
   system_message = """
   您当前正在记录血压数据，已完成：
   - ✅ 收缩压：120 mmHg
   - ⏳ 待完成：舒张压、测量时间
   """
   ```

2. **添加"重新开始"功能**
   ```python
   @tool("restart_conversation", description="重新开始对话")
   async def restart_conversation() -> str:
       """清除当前对话历史，重新开始"""
       await checkpointer.delete({"configurable": {"thread_id": session_id}})
       return "已重新开始对话"
   ```

3. **添加"查看历史"功能**
   ```python
   @tool("view_history", description="查看对话历史")
   async def view_history() -> str:
       """返回当前对话的历史记录"""
       history = await get_conversation_history(session_id, checkpointer)
       return format_history(history)
   ```

---

## 七、总结

### 7.1 核心要点

1. **LangGraph自动管理对话状态**
   - 通过checkpointer持久化保存对话历史
   - 每次调用时自动恢复历史对话
   - 支持跨时间段的对话恢复

2. **路由图不是每次都从头执行**
   - 会根据对话历史继续执行未完成的流程
   - 用户改变意图时可以重新路由
   - LLM基于完整上下文理解用户意图

3. **异常情况的处理**
   - 用户没有回复：状态保存在checkpoint中，可以恢复
   - 用户回复无关内容：LLM会理解并引导
   - 用户离开后回来：自动恢复历史对话

### 7.2 技术优势

- ✅ **持久化存储**：checkpoint不会过期，支持长期对话
- ✅ **自动恢复**：无需手动管理对话历史
- ✅ **上下文理解**：LLM基于完整历史理解用户意图
- ✅ **灵活路由**：支持意图切换和重新路由

### 7.3 注意事项

- ⚠️ **上下文长度**：需要控制对话历史长度，避免token超限
- ⚠️ **时间概念**：需要在系统提示词中说明当前时间
- ⚠️ **会话管理**：需要合理设计session_id的生成策略
- ⚠️ **用户体验**：需要添加进度提示和帮助功能

---

## 八、重新路由验证方案

### 8.1 验证场景

关于"用户改变意图时能否重新路由"的问题，详见 `V1.0-02-重新路由技术细节.md`。

**核心结论**：重新路由是完全可以实现的，具体取决于实现方案：

1. **方案一（StateGraph）**：✅ 完全支持自动重新路由
2. **方案二（独立Agent）**：✅ 需要手动实现路由检查机制
3. **方案三（混合方案）**：✅ 推荐，结合两者优点

### 8.2 验证TODO

建议在代码实现后验证以下场景：

- [ ] **正常流程**：用户在专门智能体中完成任务，不改变意图
  - 测试：用户说"我想记录血压"，然后提供数据，不改变意图
  - 预期：不会重新路由，继续在血压记录智能体中
  
- [ ] **重新路由**：用户在专门智能体中改变意图，能正确重新路由
  - 测试：用户说"我想记录血压"，然后说"算了，我想预约复诊"
  - 预期：能够识别意图变化，重新路由到复诊智能体
  
- [ ] **模糊表达**：用户模糊表达意图变化，能正确处理
  - 测试：用户说"我想记录血压"，然后说"算了"，再说"我想预约复诊"
  - 预期：能够理解用户的意图变化，正确重新路由
  
- [ ] **性能测试**：重新路由的延迟和性能影响
  - 测试：测量重新路由的延迟
  - 预期：延迟在可接受范围内（<500ms）

### 8.3 验证方法

详细的技术实现和验证方法请参考 `V1.0-02-重新路由技术细节.md`。

---

*文档版本：v1.1*  
*更新时间：2025年11月*  
*作者：@舒小龙*  
*相关文档：`V1.0-02-重新路由技术细节.md`*

