# 重新路由技术细节解析 V2.0

## 文档说明

本文档详细解答：在多智能体路由系统中，当用户在专门智能体中改变了意图时，如何实现重新路由的技术细节。

**技术架构**：基于LangGraph StateGraph实现，每次调用都经过路由节点，自动检测意图变化并重新路由。

---

## 一、问题分析

### 1.1 核心问题

**场景**：
```
用户: "我想记录血压"
Agent: [router节点识别意图，路由到血压记录智能体] "请告诉我您的收缩压是多少？"
用户: "算了，我想预约复诊"
Agent: [router节点检测到意图变化，自动重新路由到复诊智能体]
```

**关键问题**：
1. 当用户已经在专门智能体中时，如何检测到意图变化？
2. 如何实现从专门智能体返回到路由智能体？
3. 重新路由的实现机制是什么？

### 1.2 技术方案

**采用StateGraph方案**：每次调用都经过router节点，router节点自动检测意图变化并重新路由。

---

## 二、方案一：StateGraph + 条件路由（基础方案）

### 2.1 架构设计

**核心思想**：使用LangGraph的StateGraph，每次调用都经过路由节点判断。

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Optional
from langchain_core.messages import BaseMessage

class RouterState(TypedDict):
    messages: List[BaseMessage]
    current_intent: Optional[str]
    current_agent: Optional[str]
    need_reroute: bool  # 是否需要重新路由
    session_id: str
    user_id: str

# 定义路由图
router_graph = StateGraph(RouterState)

# 添加节点
router_graph.add_node("router", router_node)  # 路由节点（每次调用都经过）
router_graph.add_node("clarify_intent", clarify_intent_node)
router_graph.add_node("blood_pressure_agent", blood_pressure_agent_node)
router_graph.add_node("appointment_agent", appointment_agent_node)
router_graph.add_node("doctor_assistant_agent", doctor_assistant_agent_node)

# 设置入口点：每次调用都从router节点开始
router_graph.set_entry_point("router")

# 添加条件边：根据意图路由到对应智能体
router_graph.add_conditional_edges(
    "router",
    route_decision,
    {
        "blood_pressure": "blood_pressure_agent",
        "appointment": "appointment_agent",
        "doctor_assistant": "doctor_assistant_agent",
        "unclear": "clarify_intent"
    }
)

# 添加回边：专门智能体执行完后，返回到router节点
router_graph.add_edge("blood_pressure_agent", "router")
router_graph.add_edge("appointment_agent", "router")
router_graph.add_edge("doctor_assistant_agent", "router")
router_graph.add_edge("clarify_intent", "router")

# 编译图
agent = router_graph.compile(checkpointer=checkpointer)
```

### 2.2 路由节点实现

**关键**：每次调用时，路由节点都会检查当前意图和用户消息，判断是否需要重新路由。

```python
async def router_node(state: RouterState) -> RouterState:
    """
    路由节点：每次调用都会经过这个节点
    
    功能：
    1. 读取历史对话
    2. 识别用户意图（包括意图变化）
    3. 判断是否需要重新路由
    4. 更新状态
    """
    messages = state["messages"]
    current_intent = state.get("current_intent")
    current_agent = state.get("current_agent")
    
    # 获取最后一条用户消息
    last_user_message = None
    for msg in reversed(messages):
        if msg.type == "human":
            last_user_message = msg.content
            break
    
    if not last_user_message:
        return state
    
    # 调用意图识别工具
    intent_result = await identify_intent_tool(
        user_query=last_user_message,
        conversation_history=messages,
        current_intent=current_intent
    )
    
    new_intent = intent_result.intent_type
    confidence = intent_result.confidence
    
    # 判断是否需要重新路由
    need_reroute = False
    
    if current_intent and current_intent != new_intent:
        # 意图发生变化
        if confidence > 0.7:  # 置信度阈值
            need_reroute = True
            logger.info(f"检测到意图变化：{current_intent} → {new_intent}")
    
    # 更新状态
    state["current_intent"] = new_intent
    state["need_reroute"] = need_reroute
    
    return state

def route_decision(state: RouterState) -> str:
    """
    路由决策函数：决定下一步执行哪个节点
    """
    current_intent = state.get("current_intent")
    need_reroute = state.get("need_reroute", False)
    current_agent = state.get("current_agent")
    
    # 如果检测到需要重新路由，或者当前没有活跃的智能体
    if need_reroute or not current_agent:
        # 根据新意图路由
        if current_intent == "blood_pressure":
            state["current_agent"] = "blood_pressure_agent"
            return "blood_pressure"
        elif current_intent == "appointment":
            state["current_agent"] = "appointment_agent"
            return "appointment"
        elif current_intent == "doctor_assistant":
            state["current_agent"] = "doctor_assistant_agent"
            return "doctor_assistant"
        elif current_intent == "unclear":
            return "unclear"
        else:
            return "unclear"
    
    # 如果不需要重新路由，继续当前智能体
    if current_agent == "blood_pressure_agent":
        return "blood_pressure"
    elif current_agent == "appointment_agent":
        return "appointment"
    elif current_agent == "doctor_assistant_agent":
        return "doctor_assistant"
    
    return "unclear"
```

### 2.3 专门智能体节点实现

```python
async def blood_pressure_agent_node(state: RouterState) -> RouterState:
    """
    血压记录智能体节点
    
    注意：这个节点执行完后，会返回到router节点
    下次调用时，router节点会重新判断意图
    """
    messages = state["messages"]
    
    # 创建血压记录智能体
    agent = create_blood_pressure_agent()
    
    # 调用智能体（使用相同的thread_id）
    result = await agent.ainvoke(
        {"messages": messages},
        config={"configurable": {"thread_id": state.get("session_id")}}
    )
    
    # 更新消息列表
    state["messages"] = result["messages"]
    
    # 执行完后，返回到router节点
    # （通过图的边配置实现）
    
    return state
```

### 2.4 工作流程

**第1次调用**：
```
用户: "我想记录血压"
→ router_node: 识别意图="blood_pressure"
→ route_decision: 返回"blood_pressure"
→ blood_pressure_agent_node: 执行，返回"请告诉我您的收缩压是多少？"
→ 返回到router_node（通过边配置）
→ 保存状态：current_intent="blood_pressure", current_agent="blood_pressure_agent"
```

**第2次调用**：
```
用户: "120"
→ router_node: 识别意图="blood_pressure"（未变化）
→ route_decision: 检查need_reroute=False，返回"blood_pressure"（继续当前智能体）
→ blood_pressure_agent_node: 执行，返回"请告诉我您的舒张压是多少？"
→ 返回到router_node
→ 保存状态：current_intent="blood_pressure", current_agent="blood_pressure_agent"
```

**第3次调用**（用户改变意图）：
```
用户: "算了，我想预约复诊"
→ router_node: 识别意图="appointment"（意图变化！）
→ route_decision: 检查need_reroute=True，返回"appointment"（重新路由）
→ appointment_agent_node: 执行，返回"请告诉我您想预约哪个科室？"
→ 返回到router_node
→ 保存状态：current_intent="appointment", current_agent="appointment_agent"
```

### 2.5 优点和缺点

**优点**：
- ✅ **自动重新路由**：每次调用都经过router节点，自动检测意图变化
- ✅ **状态管理清晰**：所有状态都在RouterState中管理
- ✅ **易于扩展**：添加新智能体只需要添加节点和边

**缺点**：
- ❌ **性能开销**：每次调用都要经过router节点，增加一次意图识别
- ❌ **图结构复杂**：需要维护图的边和条件路由逻辑

---

## 三、方案三：混合方案（推荐 - 性能优化版）

### 3.1 架构设计

**核心思想**：结合两种方案的优点，使用StateGraph但优化性能。

```python
from langgraph.graph import StateGraph, END

class RouterState(TypedDict):
    messages: List[BaseMessage]
    current_intent: Optional[str]
    current_agent: Optional[str]
    last_intent_check: Optional[float]  # 上次检查意图的时间戳

# 定义路由图
router_graph = StateGraph(RouterState)

# 添加节点
router_graph.add_node("intent_check", intent_check_node)  # 轻量级意图检查
router_graph.add_node("blood_pressure_agent", blood_pressure_agent_node)
router_graph.add_node("appointment_agent", appointment_agent_node)
router_graph.add_node("doctor_assistant_agent", doctor_assistant_agent_node)

# 设置入口点
router_graph.set_entry_point("intent_check")

# 条件路由：根据意图检查结果决定
router_graph.add_conditional_edges(
    "intent_check",
    route_decision,
    {
        "blood_pressure": "blood_pressure_agent",
        "appointment": "appointment_agent",
        "doctor_assistant": "doctor_assistant_agent",
        "continue": "blood_pressure_agent"  # 继续当前智能体（需要从state中获取）
    }
)

# 专门智能体执行完后，返回到intent_check（但可以优化为不返回）
router_graph.add_edge("blood_pressure_agent", END)  # 执行完就结束
router_graph.add_edge("appointment_agent", END)
router_graph.add_edge("doctor_assistant_agent", END)
```

### 3.2 优化：智能意图检查

```python
async def intent_check_node(state: RouterState) -> RouterState:
    """
    轻量级意图检查节点
    
    优化策略：
    1. 如果当前有活跃的智能体，且用户消息很短，可能不需要重新路由
    2. 如果用户消息包含明确的意图关键词，才进行意图识别
    3. 使用缓存机制，避免重复识别
    """
    messages = state["messages"]
    current_agent = state.get("current_agent")
    
    # 获取最后一条用户消息
    last_user_message = None
    for msg in reversed(messages):
        if msg.type == "human":
            last_user_message = msg.content
            break
    
    if not last_user_message:
        return state
    
    # 优化：如果当前有活跃的智能体，且用户消息很短，可能不需要重新路由
    if current_agent and len(last_user_message) < 20:
        # 短消息，可能是继续当前任务
        # 检查是否包含明确的意图变化关键词
        if not has_intent_change_keywords(last_user_message):
            # 不包含意图变化关键词，可能不需要重新路由
            state["current_intent"] = state.get("current_intent")
            return state
    
    # 调用意图识别（可以缓存结果）
    intent_result = await identify_intent_tool(
        user_query=last_user_message,
        conversation_history=messages[-5:]  # 只使用最近5条消息
    )
    
    state["current_intent"] = intent_result.intent_type
    state["last_intent_check"] = time.time()
    
    return state

def has_intent_change_keywords(query: str) -> bool:
    """检查是否包含明确的意图变化关键词"""
    change_keywords = [
        "算了", "不想", "取消", "换个", "改一下",
        "我想", "我要", "帮我", "预约", "复诊", "挂号"
    ]
    return any(keyword in query for keyword in change_keywords)
```

### 3.3 工作流程

**第1次调用**：
```
用户: "我想记录血压"
→ intent_check_node: 识别意图="blood_pressure"
→ route_decision: 返回"blood_pressure"
→ blood_pressure_agent_node: 执行
→ END: 结束
```

**第2次调用**：
```
用户: "120"
→ intent_check_node: 
  - 检查：current_agent="blood_pressure_agent"，消息很短，不包含意图变化关键词
  - 跳过意图识别（优化）
  - 保持current_intent="blood_pressure"
→ route_decision: 返回"continue"（继续当前智能体）
→ blood_pressure_agent_node: 执行
→ END: 结束
```

**第3次调用**（用户改变意图）：
```
用户: "算了，我想预约复诊"
→ intent_check_node:
  - 检查：包含意图变化关键词"算了"、"我想"、"预约"
  - 调用意图识别：识别意图="appointment"
→ route_decision: 返回"appointment"（重新路由）
→ appointment_agent_node: 执行
→ END: 结束
```

### 3.4 优点

**优点**：
- ✅ **自动重新路由**：使用StateGraph自动管理路由
- ✅ **性能优化**：智能检查，避免不必要的意图识别
- ✅ **灵活控制**：可以根据消息内容决定是否检查意图

---

## 四、方案选择建议

### 4.1 推荐方案

**推荐使用方案三（混合方案）**，原因：

1. **自动重新路由**：使用StateGraph自动管理路由逻辑
2. **性能优化**：智能检查，避免不必要的意图识别
3. **易于维护**：路由逻辑集中管理，易于调试和扩展

### 4.2 实施建议

1. **第一阶段**：实现方案一（基础方案）
   - 简单直接，快速验证
   - 可以先实现基本功能

2. **第二阶段**：优化为方案三（混合方案）
   - 使用StateGraph优化路由逻辑
   - 添加智能检查机制
   - 优化性能

### 4.3 关键代码位置

```python
# 1. 路由节点实现
# 文件：utils/router.py
async def router_node(state: RouterState) -> RouterState:
    """路由节点：每次调用都会经过这个节点"""
    pass

def route_decision(state: RouterState) -> str:
    """路由决策函数：决定下一步执行哪个节点"""
    pass

# 2. 意图识别工具
# 文件：utils/tools/router_tools.py
@tool("identify_intent", description="识别用户意图")
async def identify_intent(...) -> IntentResult:
    """识别用户意图"""
    pass

# 3. 专门智能体节点实现
# 文件：utils/agents/blood_pressure_agent.py
async def blood_pressure_agent_node(state: RouterState) -> RouterState:
    """血压记录智能体节点"""
    pass
```

---

## 五、实现验证方案

### 5.1 测试场景

**测试用例1：正常流程（不改变意图）**
```
用户: "我想记录血压"
预期: router节点识别意图="blood_pressure"，路由到血压记录智能体
用户: "120"
预期: router节点识别意图="blood_pressure"（未变化），继续血压记录智能体
用户: "80"
预期: router节点识别意图="blood_pressure"（未变化），继续血压记录智能体
```

**测试用例2：用户改变意图**
```
用户: "我想记录血压"
预期: router节点识别意图="blood_pressure"，路由到血压记录智能体
用户: "120"
预期: router节点识别意图="blood_pressure"（未变化），继续血压记录智能体
用户: "算了，我想预约复诊"
预期: router节点识别意图="appointment"（意图变化），自动重新路由到复诊智能体
```

**测试用例3：用户模糊表达**
```
用户: "我想记录血压"
预期: router节点识别意图="blood_pressure"，路由到血压记录智能体
用户: "算了"
预期: router节点识别意图可能不明确，需要澄清或继续当前智能体
用户: "我想预约复诊"
预期: router节点识别意图="appointment"（意图变化），自动重新路由到复诊智能体
```

### 5.2 验证步骤

**步骤1：实现路由图**
```python
# 实现StateGraph路由图
router_graph = StateGraph(RouterState)
# 添加节点和边
# 编译图
agent = router_graph.compile(checkpointer=checkpointer)
```

**步骤2：添加日志记录**
```python
logger.info(f"当前智能体: {current_agent}")
logger.info(f"用户消息: {user_query}")
logger.info(f"识别意图: {new_intent}, 置信度: {confidence}")
logger.info(f"是否需要重新路由: {need_reroute}")
```

**步骤3：运行测试用例**
```bash
# 使用测试脚本或手动测试
python test_reroute.py
```

**步骤4：检查checkpoint状态**
```python
# 检查checkpoint中的对话历史和状态
checkpoint = await checkpointer.aget(
    {"configurable": {"thread_id": session_id}}
)
print(f"对话历史: {checkpoint['channel_values']['messages']}")
print(f"状态: {checkpoint['channel_values']['state']}")
```

### 5.3 验证指标

1. **重新路由准确性**
   - 用户明确改变意图时，是否能正确识别并重新路由
   - 用户没有改变意图时，是否不会错误地重新路由

2. **性能影响**
   - 重新路由的延迟是否可接受
   - 意图识别的开销是否合理

3. **用户体验**
   - 重新路由是否自然流畅
   - 用户是否感知到智能体切换

---

## 六、总结

### 6.1 核心结论

**重新路由是完全可以实现的**，采用StateGraph方案：

1. **方案一（StateGraph基础方案）**：✅ 完全支持自动重新路由
2. **方案三（混合方案）**：✅ 推荐，结合自动重新路由和性能优化

### 6.2 技术要点

1. **意图检测**：每次调用时router节点检查用户意图是否变化
2. **状态管理**：所有状态都在RouterState中管理
3. **路由决策**：根据意图变化决定是否重新路由
4. **性能优化**：智能检查，避免不必要的意图识别

### 6.3 验证TODO

建议在代码实现后验证以下场景：

- [ ] 正常流程：用户在专门智能体中完成任务，不改变意图
- [ ] 重新路由：用户在专门智能体中改变意图，能正确重新路由
- [ ] 模糊表达：用户模糊表达意图变化，能正确处理
- [ ] 性能测试：重新路由的延迟和性能影响

---

*文档版本：v2.0*  
*更新时间：2025年11月*  
*作者：@舒小龙*  
*相关文档：`V2.0-00-设计方案.md`、`V2.0-01-路由流程场景解析.md`*

