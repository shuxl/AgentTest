# LangGraph路由流程场景解析 V2.0

## 文档说明

本文档解答多智能体路由系统中三种实际场景的业务表现和技术原理：
1. 正常情况：患者在专门智能体中完成业务处理
2. 异常情况：患者进入专门智能体后没有回复
3. 用户离开：患者离开后第二天回来继续对话

**技术架构**：基于LangGraph StateGraph实现，每次调用都经过路由节点，自动检测意图变化并重新路由。

---

## 一、核心机制理解

### 1.1 LangGraph的工作机制

LangGraph的核心特点是**状态保持**和**自动恢复**：

1. **状态保存**：每次Agent执行后，会自动将对话状态保存到checkpointer（PostgreSQL）
2. **状态恢复**：下次调用时，通过`thread_id`自动恢复之前的对话历史
3. **消息累积**：对话历史会不断累积，形成完整的上下文

### 1.2 StateGraph路由机制

**核心特点**：每次调用都经过路由节点（router_node）

```python
# 每次调用Agent时，都会传入相同的thread_id
config = {"configurable": {"thread_id": session_id}}

# StateGraph的执行流程：
# 1. 从checkpointer中读取该thread_id的历史对话和状态
# 2. 进入router节点（入口点）
# 3. router节点识别意图，判断是否需要重新路由
# 4. 根据路由决策，执行对应的专门智能体节点
# 5. 专门智能体执行完后，返回到router节点
# 6. 保存新的对话状态到checkpointer
result = await agent.ainvoke(
    {"messages": [{"role": "user", "content": new_query}]},
    config=config
)
```

### 1.3 路由图的执行流程

```
用户请求 → FastAPI接口 → StateGraph Agent.ainvoke()
    ↓
读取历史对话和状态（从checkpointer）
    ↓
进入router节点（入口点）
    ↓
router节点：识别意图，判断是否需要重新路由
    ↓
路由决策：根据意图路由到对应智能体节点
    ↓
执行专门智能体节点
    ↓
返回到router节点（通过边配置）
    ↓
保存新的对话状态（到checkpointer）
    ↓
返回结果
```

**重要**：LangGraph**不是**每次都从头开始执行路由图，而是：
- 每次调用都从router节点开始
- router节点会根据历史状态和当前消息判断意图
- 如果意图变化，自动重新路由到新智能体
- 如果意图未变，继续当前智能体

---

## 二、场景一：正常情况 - 患者完成业务处理

### 2.1 业务流程示例

**对话流程**：
```
用户: "我想记录血压"
Agent: [router节点识别意图="blood_pressure"，路由到血压记录智能体] "请告诉我您的收缩压是多少？"
用户: "120"
Agent: [router节点识别意图="blood_pressure"（未变化），继续血压记录智能体] "好的，请告诉我您的舒张压是多少？"
用户: "80"
Agent: [继续血压记录智能体] "请问您是什么时候测量的？"
用户: "今天早上8点"
Agent: [调用record_blood_pressure工具] "成功保存血压记录..."
```

### 2.2 实际表现

1. **第一次请求**（"我想记录血压"）
   - router节点识别意图 → `blood_pressure`
   - 路由决策：路由到血压记录智能体节点
   - 血压记录智能体节点开始引导流程
   - 保存状态：current_intent="blood_pressure", current_agent="blood_pressure_agent"
   - 返回到router节点

2. **第二次请求**（"120"）
   - 进入router节点：识别意图="blood_pressure"（未变化）
   - 路由决策：need_reroute=False，继续血压记录智能体
   - 血压记录智能体接收收缩压值，继续询问舒张压
   - 保存状态：current_intent="blood_pressure", current_agent="blood_pressure_agent"

3. **第三次请求**（"80"）
   - 进入router节点：识别意图="blood_pressure"（未变化）
   - 路由决策：继续血压记录智能体
   - 血压记录智能体接收舒张压值，继续询问时间
   - 保存状态：已收集收缩压=120，舒张压=80，等待时间

4. **第四次请求**（"今天早上8点"）
   - 进入router节点：识别意图="blood_pressure"（未变化）
   - 路由决策：继续血压记录智能体
   - 血压记录智能体调用工具保存数据
   - 保存状态：任务完成

### 2.3 技术原理

**对话历史和状态在PostgreSQL中的存储**（简化示例）：

```json
{
  "thread_id": "session_123",
  "state": {
    "current_intent": "blood_pressure",
    "current_agent": "blood_pressure_agent",
    "need_reroute": false
  },
  "messages": [
    {"role": "system", "content": "..."},
    {"role": "user", "content": "我想记录血压"},
    {"role": "assistant", "content": "请告诉我您的收缩压是多少？"},
    {"role": "user", "content": "120"},
    {"role": "assistant", "content": "好的，请告诉我您的舒张压是多少？"},
    {"role": "user", "content": "80"},
    {"role": "assistant", "content": "请问您是什么时候测量的？"},
    {"role": "user", "content": "今天早上8点"},
    {"role": "assistant", "content": "成功保存血压记录..."}
  ]
}
```

**每次调用时的处理**：
```python
# 第1次调用
agent.ainvoke(
    {"messages": [{"role": "user", "content": "我想记录血压"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer中：空 → router节点识别意图 → 路由到血压记录智能体 → 保存状态

# 第2次调用
agent.ainvoke(
    {"messages": [{"role": "user", "content": "120"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer中：读取历史对话和状态 → router节点识别意图（未变化） → 继续血压记录智能体 → 保存状态

# 第3次调用
agent.ainvoke(
    {"messages": [{"role": "user", "content": "80"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer中：读取历史对话和状态 → router节点识别意图（未变化） → 继续血压记录智能体 → 保存状态

# ... 以此类推
```

**关键点**：
- LangGraph会自动从checkpointer读取历史对话和状态
- 每次调用都从router节点开始
- router节点自动检测意图变化
- 如果意图未变，继续当前智能体
- 如果意图变化，自动重新路由

---

## 三、场景二：异常情况 - 患者没有回复

### 3.1 业务流程示例

**对话流程**：
```
用户: "我想记录血压"
Agent: [router节点识别意图，路由到血压记录智能体] "请告诉我您的收缩压是多少？"
用户: [没有回复，或者回复了无关内容]
```

### 3.2 实际表现分析

#### 情况A：用户完全没有回复（超时）

**实际表现**：
- Agent在等待用户回复，没有新的执行
- 对话状态保存在checkpointer中，状态为：current_intent="blood_pressure", current_agent="blood_pressure_agent"
- 如果用户一直不回复，对话会保持在这个状态

**技术原理**：
```
时间点1: 用户发送"我想记录血压"
  → router节点识别意图 → 路由到血压记录智能体 → 保存状态
  → checkpointer中保存完整的对话历史和状态

时间点2: 用户没有回复（1小时后）
  → 没有新的Agent执行
  → checkpointer中的状态保持不变
  → 如果配置了TTL，Redis中的会话状态可能过期，但PostgreSQL中的checkpoint不会过期

时间点3: 用户回复（无论多久后）
  → Agent读取checkpointer中的历史对话和状态
  → 进入router节点 → 识别意图（未变化） → 继续血压记录智能体
```

#### 情况B：用户回复了无关内容

**实际表现**（取决于LLM的智能程度）：

**示例1：LLM理解上下文，引导用户**
```
用户: "我想记录血压"
Agent: "请告诉我您的收缩压是多少？"
用户: "今天天气真好"
Agent: [router节点识别意图="blood_pressure"（未变化）]
Agent: "我理解您的话题，但我们现在正在记录血压数据。请告诉我您的收缩压是多少？"
```

**示例2：用户改变了意图**
```
用户: "我想记录血压"
Agent: "请告诉我您的收缩压是多少？"
用户: "算了，我想预约复诊"
Agent: [router节点识别意图="appointment"（意图变化！）]
Agent: [自动重新路由到复诊智能体] "请告诉我您想预约哪个科室？"
```

**技术原理**：
```python
# 用户发送无关消息时
agent.ainvoke(
    {"messages": [{"role": "user", "content": "今天天气真好"}]},
    config={"configurable": {"thread_id": "session_123"}}
)

# StateGraph的处理流程：
# 1. 从checkpointer读取历史对话和状态
#    - 之前：用户说"我想记录血压"，Agent说"请告诉我您的收缩压是多少？"
#    - 状态：current_intent="blood_pressure", current_agent="blood_pressure_agent"
# 2. 进入router节点
# 3. router节点识别意图：仍然是"blood_pressure"（未变化）
# 4. 路由决策：继续血压记录智能体
# 5. 血压记录智能体基于完整上下文生成回复：引导用户回到原任务

# 用户改变意图时
agent.ainvoke(
    {"messages": [{"role": "user", "content": "算了，我想预约复诊"}]},
    config={"configurable": {"thread_id": "session_123"}}
)

# StateGraph的处理流程：
# 1. 从checkpointer读取历史对话和状态
# 2. 进入router节点
# 3. router节点识别意图：识别为"appointment"（意图变化！）
# 4. 路由决策：need_reroute=True，路由到复诊智能体
# 5. 复诊智能体开始新的流程
```

**关键点**：
- router节点会自动检测意图变化
- 如果意图未变，继续当前智能体（LLM会引导用户回到原任务）
- 如果意图变化，自动重新路由到新智能体（详见 `V2.0-02-重新路由技术细节.md`）

### 3.3 优化建议

**针对"用户没有回复"的情况**：

1. **超时提醒机制**
   ```python
   # 可以在后端添加定时任务
   # 检查长时间未活跃的会话，发送提醒
   async def check_inactive_sessions():
       # 查询超过30分钟未更新的会话
       inactive_sessions = await get_inactive_sessions(minutes=30)
       for session in inactive_sessions:
           # 发送提醒消息
           await send_reminder(session.user_id, "您还在记录血压吗？")
   ```

2. **上下文清理机制**
   ```python
   # 如果用户长时间没有回复，可以清理上下文
   # 或者添加一个"重新开始"的机制
   if user_says_restart():
       # 清除checkpointer中的历史
       await checkpointer.delete({"configurable": {"thread_id": session_id}})
   ```

---

## 四、场景三：用户离开 - 第二天回来继续对话

### 4.1 业务流程示例

**第一天**：
```
用户: "我想记录血压"
Agent: "请告诉我您的收缩压是多少？"
用户: "120"
Agent: "好的，请告诉我您的舒张压是多少？"
用户: [离开，没有回复]
```

**第二天**：
```
用户: "80"
Agent: [router节点识别意图="blood_pressure"（未变化），继续血压记录智能体] "请问您是什么时候测量的？"
```

### 4.2 实际表现

#### 情况A：用户继续之前的任务

**实际表现**：
```
第二天，用户说："80"
Agent会自动：
1. 从checkpointer读取昨天的对话历史和状态
2. router节点识别意图：仍然是"blood_pressure"（未变化）
3. 路由决策：继续血压记录智能体
4. 血压记录智能体理解上下文：已收集收缩压=120，现在用户提供舒张压=80
5. 继续引导流程：询问测量时间
```

**技术原理**：

```python
# 第一天：用户发送"我想记录血压"
agent.ainvoke(
    {"messages": [{"role": "user", "content": "我想记录血压"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer保存：状态={current_intent="blood_pressure", current_agent="blood_pressure_agent"}

# 第一天：用户发送"120"
agent.ainvoke(
    {"messages": [{"role": "user", "content": "120"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer保存：状态={current_intent="blood_pressure", current_agent="blood_pressure_agent"}

# 第二天：用户发送"80"
agent.ainvoke(
    {"messages": [{"role": "user", "content": "80"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# checkpointer读取：昨天的所有历史对话和状态
# router节点：识别意图="blood_pressure"（未变化）
# 路由决策：继续血压记录智能体
# 血压记录智能体：看到完整历史，理解80是舒张压，继续询问时间
```

**关键点**：
- ✅ **PostgreSQL的checkpoint是持久化的**，不会因为时间过期而丢失
- ✅ **LangGraph会自动恢复历史对话和状态**，无需手动处理
- ✅ **router节点自动检测意图**，如果未变化则继续当前智能体
- ✅ **LLM基于完整上下文理解**，知道当前处于哪个流程

#### 情况B：用户改变了意图

**实际表现**：
```
第二天，用户说："算了，我想预约复诊"
Agent会：
1. 从checkpointer读取昨天的对话历史和状态
2. router节点识别意图：识别为"appointment"（意图变化！）
3. 路由决策：need_reroute=True，重新路由到复诊智能体
4. 复诊智能体开始新的流程
```

**技术原理**：

```python
# 第二天：用户发送"算了，我想预约复诊"
agent.ainvoke(
    {"messages": [{"role": "user", "content": "算了，我想预约复诊"}]},
    config={"configurable": {"thread_id": "session_123"}}
)

# StateGraph的处理：
# 1. 读取历史对话和状态（昨天的血压记录对话）
# 2. 进入router节点
# 3. router节点识别意图：识别为"appointment"（意图变化！）
# 4. 路由决策：need_reroute=True，路由到复诊智能体
# 5. 复诊智能体开始新的流程（不依赖之前的血压记录流程）
```

**关键点**：
- router节点会自动检测意图变化
- 如果意图变化，自动重新路由到新智能体（详见 `V2.0-02-重新路由技术细节.md`）
- 之前未完成的流程可以被"覆盖"或"暂停"

### 4.3 时间相关的问题

#### 问题1：checkpoint会过期吗？

**答案**：**不会**

- **PostgreSQL的checkpoint是持久化的**，只要数据库不删除，checkpoint就一直存在
- **Redis的会话状态可能过期**（根据TTL配置），但checkpoint不受影响
- **即使Redis会话过期，checkpoint仍然可以恢复**

**示例**：
```python
# 第一天：创建会话
session_id = "session_123"
await session_manager.create_session(user_id, session_id, ttl=3600)  # Redis TTL=1小时

# 第二天：Redis会话可能已过期，但checkpoint还在
# 如果用户再次使用相同的session_id，可以恢复对话
agent.ainvoke(
    {"messages": [{"role": "user", "content": "继续"}]},
    config={"configurable": {"thread_id": "session_123"}}
)
# LangGraph会自动从checkpoint恢复历史对话和状态
# router节点会根据历史状态和当前消息判断意图
```

#### 问题2：如何处理"昨天"、"今天"等时间概念？

**答案**：需要在系统提示词中说明

```python
system_message = """
当前日期时间：{current_datetime}

当用户提到"昨天"、"今天"、"明天"等时间概念时：
- 请根据当前日期时间计算具体日期
- 例如：如果今天是2025-11-05，用户说"昨天"，指的是2025-11-04
"""
```

---

## 五、技术原理总结

### 5.1 LangGraph的状态管理机制

1. **Checkpointer（短期记忆）**
   - 存储在PostgreSQL中
   - 以`thread_id`为键，保存完整的对话历史和状态
   - 持久化存储，不会过期
   - 每次Agent执行后自动保存

2. **消息累积机制**
   - 新消息会追加到历史消息后面
   - LLM基于完整的历史上下文生成回复
   - 支持多轮对话的连续性

3. **自动恢复机制**
   - 每次调用时，自动从checkpointer读取历史对话和状态
   - 无需手动管理对话历史
   - 支持跨时间段的对话恢复

### 5.2 StateGraph路由图的执行逻辑

**重要理解**：每次调用都从router节点开始，router节点自动检测意图变化

1. **首次调用**：router节点识别意图，路由到专门智能体
2. **后续调用**：
   - 每次调用都从router节点开始
   - router节点识别意图，判断是否需要重新路由
   - 如果意图未变，继续当前智能体
   - 如果意图变化，自动重新路由到新智能体

**示例**：
```python
# 第1次调用：router节点识别意图="blood_pressure"，路由到血压记录智能体
# 状态：current_intent="blood_pressure", current_agent="blood_pressure_agent"

# 第2次调用：router节点识别意图="blood_pressure"（未变化），继续血压记录智能体

# 第3次调用：用户说"我想预约复诊"
# router节点识别意图="appointment"（意图变化！），自动重新路由到复诊智能体
```

### 5.3 异常情况的处理策略

1. **用户没有回复**
   - 对话状态保存在checkpoint中
   - 用户回来后可以继续对话
   - router节点会自动识别意图，继续之前流程

2. **用户回复无关内容**
   - router节点识别意图（未变化）
   - 继续当前智能体，LLM会引导用户回到原任务
   - 如果用户明确改变了意图，router节点会检测到并重新路由

3. **用户离开后回来**
   - checkpoint持久化保存，不会丢失
   - 自动恢复历史对话和状态
   - router节点会根据历史状态和当前消息判断意图
   - 支持跨时间段的对话

---

## 六、最佳实践建议

### 6.1 会话管理

1. **使用稳定的session_id**
   ```python
   # 推荐：使用用户ID + 时间戳生成稳定的session_id
   session_id = f"{user_id}_{datetime.now().strftime('%Y%m%d')}"
   
   # 或者：使用UUID，但需要用户记住session_id
   session_id = str(uuid.uuid4())
   ```

2. **检查会话状态**
   ```python
   # 在调用Agent前，检查会话状态
   session = await session_manager.get_session(user_id, session_id)
   if session and session.get("status") == "completed":
       # 可以提示用户是否继续之前的对话
       pass
   ```

### 6.2 上下文管理

1. **清理过长的上下文**
   ```python
   # 使用trimmed_messages_hook自动清理
   def trimmed_messages_hook(state):
       trimmed_messages = trim_messages(
           messages=state["messages"],
           max_tokens=2000,
           strategy="last",
           start_on="human"
       )
       return {"messages": trimmed_messages}
   ```

2. **添加对话总结功能**
   ```python
   @tool("summarize_conversation", description="总结当前对话")
   async def summarize_conversation() -> str:
       """将当前对话总结为简短描述"""
       # 调用LLM总结对话
       pass
   ```

### 6.3 用户体验优化

1. **添加进度提示**
   ```python
   # 在系统提示词中说明当前进度
   system_message = """
   您当前正在记录血压数据，已完成：
   - ✅ 收缩压：120 mmHg
   - ⏳ 待完成：舒张压、测量时间
   """
   ```

2. **添加"重新开始"功能**
   ```python
   @tool("restart_conversation", description="重新开始对话")
   async def restart_conversation() -> str:
       """清除当前对话历史，重新开始"""
       await checkpointer.delete({"configurable": {"thread_id": session_id}})
       return "已重新开始对话"
   ```

---

## 七、总结

### 7.1 核心要点

1. **LangGraph自动管理对话状态**
   - 通过checkpointer持久化保存对话历史和状态
   - 每次调用时自动恢复历史对话和状态
   - 支持跨时间段的对话恢复

2. **StateGraph路由机制**
   - 每次调用都从router节点开始
   - router节点自动检测意图变化
   - 如果意图未变，继续当前智能体
   - 如果意图变化，自动重新路由到新智能体

3. **异常情况的处理**
   - 用户没有回复：状态保存在checkpoint中，可以恢复
   - 用户回复无关内容：router节点识别意图，继续当前智能体或重新路由
   - 用户离开后回来：自动恢复历史对话和状态

### 7.2 技术优势

- ✅ **持久化存储**：checkpoint不会过期，支持长期对话
- ✅ **自动恢复**：无需手动管理对话历史
- ✅ **上下文理解**：LLM基于完整历史理解用户意图
- ✅ **自动重新路由**：router节点自动检测意图变化并重新路由

### 7.3 注意事项

- ⚠️ **上下文长度**：需要控制对话历史长度，避免token超限
- ⚠️ **时间概念**：需要在系统提示词中说明当前时间
- ⚠️ **会话管理**：需要合理设计session_id的生成策略
- ⚠️ **性能优化**：router节点每次调用都会执行，需要优化意图识别性能

---

*文档版本：v2.0*  
*更新时间：2025年11月*  
*作者：@舒小龙*  
*相关文档：`V2.0-00-设计方案.md`、`V2.0-02-重新路由技术细节.md`*

