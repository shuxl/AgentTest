# V2.0-03-长期记忆设计

## 1. 概述

### 1.1 文档目的

本文档描述多智能体路由系统的长期记忆设计方案，定义哪些客户信息值得做长期记忆，以及长期记忆的架构设计和实现方案。

### 1.2 背景

在多智能体路由系统中，我们使用两种记忆机制：

- **短期记忆（Checkpointer）**：保存单次会话的对话历史和状态，用于维持对话上下文
- **长期记忆（Store）**：保存跨会话的用户信息，用于个性化服务和智能体学习

当前系统已经实现了基础的长期记忆机制（使用LangGraph的`AsyncPostgresStore`），但仅用于存储用户设置信息。本文档将扩展长期记忆的设计，定义更全面的客户信息存储方案。

### 1.3 相关文档

- `V2.0-10-总体设计.md`：系统总体架构设计
- `V2.0-20-健康档案存储详细设计.md`：健康档案存储系统详细设计
- `V2.0-12-血压记录智能体详细设计.md`：血压记录智能体设计
- `V2.0-13-复诊管理智能体详细设计.md`：复诊管理智能体设计
- `V2.0-14-诊断智能体架构设计.md`：诊断智能体系统设计

## 2. 需要长期记忆的客户信息

### 2.1 信息分类

根据信息的性质、使用频率和重要性，我们将需要长期记忆的客户信息分为以下几类：

#### 2.1.1 用户偏好和设置（User Preferences & Settings）

**信息类型**：
- 用户界面偏好（语言、时区、日期格式等）
- 通知偏好（是否接收提醒、提醒方式等）
- 交互偏好（对话风格、回复长度等）
- 功能偏好（常用功能、快捷方式等）

**存储理由**：
- 跨会话保持用户个性化体验
- 减少用户重复设置
- 提升用户体验

**当前实现**：
- ✅ 已实现：使用`store`的`memories`命名空间存储用户设置信息

#### 2.1.2 健康档案信息（Health Profile）

**信息类型**：
- **基本信息**：
  - 年龄、性别、身高、体重
  - 血型、过敏史
  - 既往病史、家族病史
  - 常用药物、药物过敏史
- **健康指标基线**：
  - 正常血压范围（个人基线）
  - 正常心率范围
  - 其他健康指标基线
- **健康目标**：
  - 血压控制目标
  - 体重管理目标
  - 其他健康目标

**存储理由**：
- 诊断智能体需要了解患者基本信息，提供更准确的诊断建议
- 血压记录智能体需要了解个人基线，判断异常情况
- 复诊管理智能体需要了解既往病史，推荐合适的科室和医生

**使用场景**：
- 诊断智能体在诊断时自动获取患者基本信息
- 血压记录智能体在记录血压时，自动判断是否异常
- 复诊管理智能体在预约时，推荐相关科室

#### 2.1.3 用户习惯和模式（User Habits & Patterns）

**信息类型**：
- **时间习惯**：
  - 常用的测量时间（如每天早上8点测量血压）
  - 常用的预约时间偏好（如偏好下午就诊）
  - 活跃时间段（如用户通常在晚上使用系统）
- **行为模式**：
  - 常用的科室（如经常看心内科）
  - 常用的医生（如偏好某位医生）
  - 常用的功能（如经常查询血压记录）
- **交互模式**：
  - 常用的表达方式（如用户习惯说"记录血压"而不是"添加血压"）
  - 常用的查询方式（如用户习惯按日期查询而不是按范围查询）

**存储理由**：
- 智能体可以主动提醒用户（如"您通常在这个时间测量血压"）
- 智能体可以预测用户意图，提供更快的响应
- 智能体可以学习用户习惯，提供个性化建议

**使用场景**：
- 血压记录智能体主动提醒用户测量血压
- 复诊管理智能体推荐用户常用的科室和医生
- 路由智能体根据用户习惯优化意图识别

#### 2.1.4 诊断历史和学习（Diagnosis History & Learning）

**信息类型**：
- **诊断历史**：
  - 历史诊断记录（诊断时间、科室、诊断结果、诊断建议）
  - 诊断反馈（用户对诊断建议的反馈、是否采纳建议）
  - 诊断效果（诊断后的治疗效果、复查结果）
- **学习信息**：
  - 医生常用的诊断思路和模式
  - 成功案例（诊断准确、效果好的案例）
  - 失败案例（诊断不准确、需要改进的案例）
  - 诊断偏好（医生偏好的诊断方法、检查项目等）

**存储理由**：
- 诊断智能体可以学习医生的诊断模式，提供更符合医生习惯的建议
- 诊断智能体可以基于历史诊断记录，提供更准确的建议
- 诊断智能体可以基于反馈不断优化

**使用场景**：
- 诊断智能体在诊断时，参考历史诊断记录
- 诊断智能体在生成建议时，参考医生的诊断偏好
- 诊断智能体在检索知识库时，优先考虑历史成功的案例

#### 2.1.5 用户反馈和评价（User Feedback & Evaluation）

**信息类型**：
- **服务质量反馈**：
  - 对智能体回复的满意度评分
  - 对智能体功能的评价
  - 对系统性能的评价（响应时间、准确性等）
- **改进建议**：
  - 用户提出的功能改进建议
  - 用户报告的问题和bug
  - 用户期望的功能

**存储理由**：
- 系统可以基于反馈不断优化
- 系统可以识别问题，及时改进
- 系统可以了解用户需求，指导产品迭代

**使用场景**：
- 系统分析用户反馈，优化智能体回复质量
- 系统识别常见问题，改进智能体逻辑
- 产品团队基于反馈制定产品规划

### 2.2 信息优先级

根据信息的重要性和使用频率，我们将信息分为三个优先级：

| 优先级 | 信息类型 | 存储要求 | 更新频率 |
|--------|---------|---------|---------|
| **P0（高优先级）** | 健康档案信息、用户偏好和设置 | 必须存储，实时更新 | 实时 |
| **P1（中优先级）** | 用户习惯和模式、诊断历史 | 建议存储，定期更新 | 每日/每周 |
| **P2（低优先级）** | 用户反馈和评价 | 可选存储，批量更新 | 每周/每月 |

## 3. 长期记忆架构设计

### 3.1 存储架构

#### 3.1.1 存储层次

```
┌─────────────────────────────────────────────────────────┐
│              长期记忆存储层（Long-term Memory）          │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌──────────────────────────────────────────────────┐  │
│  │  LangGraph Store (AsyncPostgresStore)            │  │
│  │  - 非结构化数据存储                                │  │
│  │  - 支持向量检索                                   │  │
│  │  - 命名空间隔离                                   │  │
│  └──────────────────────────────────────────────────┘  │
│                          │                               │
│                          ▼                               │
│  ┌──────────────────────────────────────────────────┐  │
│  │  PostgreSQL 业务表 (SQLAlchemy ORM)             │  │
│  │  - 结构化数据存储                                 │  │
│  │  - 关系型数据管理                                 │  │
│  │  - 事务支持                                       │  │
│  └──────────────────────────────────────────────────┘  │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

#### 3.1.2 存储选择原则

**使用Store存储**：
- 非结构化数据（如用户偏好、诊断历史、反馈等）
- 需要向量检索的数据（如诊断案例、知识库等）
- 灵活扩展的数据（如用户习惯、模式等）

**使用业务表存储**：
- 结构化数据（如健康档案、诊断记录等）
- 需要关系查询的数据（如用户-诊断记录关系）
- 需要事务保证的数据（如血压记录、预约记录等）

### 3.2 命名空间设计

#### 3.2.1 Store命名空间

使用LangGraph Store的命名空间机制，按信息类型和用户ID组织数据：

```
命名空间结构：
(namespace_type, user_id)

命名空间类型：
- "memories": 用户记忆（偏好、设置、习惯等）
- "health_profile": 健康档案信息
- "diagnosis_history": 诊断历史
- "feedback": 用户反馈
- "patterns": 用户行为模式
```

**示例**：
```python
# 用户偏好
namespace = ("memories", user_id)
await store.aput(namespace, "preferences", {
    "language": "zh-CN",
    "timezone": "Asia/Shanghai",
    "notification_enabled": True
})

# 健康档案
namespace = ("health_profile", user_id)
await store.aput(namespace, "basic_info", {
    "age": 45,
    "gender": "male",
    "allergies": ["penicillin"],
    "medical_history": ["hypertension"]
})

# 诊断历史
namespace = ("diagnosis_history", user_id)
await store.aput(namespace, f"diagnosis_{diagnosis_id}", {
    "timestamp": "2025-01-15T10:30:00",
    "department": "cardiology",
    "symptoms": ["chest pain", "shortness of breath"],
    "diagnosis": "angina",
    "feedback": "helpful"
})
```

#### 3.2.2 业务表设计

对于结构化数据，使用SQLAlchemy ORM定义数据模型：

**健康档案表（health_profiles）**：
```python
class HealthProfile(Base):
    __tablename__ = "health_profiles"
    
    id = Column(Integer, primary_key=True)
    user_id = Column(String(255), nullable=False, unique=True)
    age = Column(Integer)
    gender = Column(String(10))
    height = Column(Float)  # 身高（cm）
    weight = Column(Float)  # 体重（kg）
    blood_type = Column(String(10))
    allergies = Column(JSON)  # 过敏史列表
    medical_history = Column(JSON)  # 既往病史列表
    family_history = Column(JSON)  # 家族病史列表
    medications = Column(JSON)  # 常用药物列表
    baseline_bp_systolic = Column(Integer)  # 基线收缩压
    baseline_bp_diastolic = Column(Integer)  # 基线舒张压
    health_goals = Column(JSON)  # 健康目标
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, onupdate=func.now())
```

**诊断历史表（diagnosis_records）**：
```python
class DiagnosisRecord(Base):
    __tablename__ = "diagnosis_records"
    
    id = Column(Integer, primary_key=True)
    user_id = Column(String(255), nullable=False)
    session_id = Column(String(255))  # 关联会话ID
    department = Column(String(50))  # 科室
    symptoms = Column(JSON)  # 症状列表
    diagnosis = Column(Text)  # 诊断结果
    suggestions = Column(Text)  # 诊断建议
    feedback = Column(String(20))  # 反馈：helpful, not_helpful, neutral
    feedback_comment = Column(Text)  # 反馈评论
    created_at = Column(DateTime, server_default=func.now())
    
    # 索引
    __table_args__ = (
        Index('idx_user_department', 'user_id', 'department'),
        Index('idx_created_at', 'created_at'),
    )
```

### 3.3 数据访问接口设计

#### 3.3.1 Store访问接口

创建统一的长期记忆访问接口，封装Store操作：

```python
class LongTermMemoryManager:
    """长期记忆管理器"""
    
    def __init__(self, store: AsyncPostgresStore):
        self.store = store
    
    # 用户偏好和设置
    async def get_user_preferences(self, user_id: str) -> Dict[str, Any]:
        """获取用户偏好"""
        namespace = ("memories", user_id)
        preferences = await self.store.aget(namespace, "preferences")
        return preferences.value if preferences else {}
    
    async def update_user_preferences(self, user_id: str, preferences: Dict[str, Any]):
        """更新用户偏好"""
        namespace = ("memories", user_id)
        await self.store.aput(namespace, "preferences", preferences)
    
    # 健康档案
    async def get_health_profile(self, user_id: str) -> Dict[str, Any]:
        """获取健康档案"""
        namespace = ("health_profile", user_id)
        profile = await self.store.aget(namespace, "profile")
        return profile.value if profile else {}
    
    async def update_health_profile(self, user_id: str, profile: Dict[str, Any]):
        """更新健康档案"""
        namespace = ("health_profile", user_id)
        await self.store.aput(namespace, "profile", profile)
    
    # 诊断历史
    async def add_diagnosis_record(self, user_id: str, diagnosis_id: str, record: Dict[str, Any]):
        """添加诊断记录"""
        namespace = ("diagnosis_history", user_id)
        await self.store.aput(namespace, f"diagnosis_{diagnosis_id}", record)
    
    async def search_diagnosis_history(self, user_id: str, query: str, limit: int = 10) -> List[Dict[str, Any]]:
        """搜索诊断历史"""
        namespace = ("diagnosis_history", user_id)
        results = await self.store.asearch(namespace, query, limit=limit)
        return [result.value for result in results]
    
    # 用户习惯和模式
    async def update_user_pattern(self, user_id: str, pattern_type: str, pattern_data: Dict[str, Any]):
        """更新用户模式"""
        namespace = ("patterns", user_id)
        await self.store.aput(namespace, pattern_type, pattern_data)
    
    async def get_user_patterns(self, user_id: str) -> Dict[str, Any]:
        """获取用户模式"""
        namespace = ("patterns", user_id)
        patterns = await self.store.asearch(namespace, "")
        return {pattern.key: pattern.value for pattern in patterns}
```

#### 3.3.2 业务表访问接口

使用SQLAlchemy ORM和CRUD模式访问业务表：

```python
# 健康档案CRUD
class HealthProfileCRUD:
    async def get_by_user_id(self, session: AsyncSession, user_id: str) -> Optional[HealthProfile]:
        """根据用户ID获取健康档案"""
        result = await session.execute(
            select(HealthProfile).where(HealthProfile.user_id == user_id)
        )
        return result.scalar_one_or_none()
    
    async def create_or_update(self, session: AsyncSession, user_id: str, profile_data: Dict[str, Any]) -> HealthProfile:
        """创建或更新健康档案"""
        profile = await self.get_by_user_id(session, user_id)
        if profile:
            # 更新
            for key, value in profile_data.items():
                setattr(profile, key, value)
            profile.updated_at = datetime.now()
        else:
            # 创建
            profile = HealthProfile(user_id=user_id, **profile_data)
            session.add(profile)
        await session.commit()
        return profile

# 诊断历史CRUD
class DiagnosisRecordCRUD:
    async def create(self, session: AsyncSession, record_data: Dict[str, Any]) -> DiagnosisRecord:
        """创建诊断记录"""
        record = DiagnosisRecord(**record_data)
        session.add(record)
        await session.commit()
        return record
    
    async def get_by_user_id(self, session: AsyncSession, user_id: str, limit: int = 10) -> List[DiagnosisRecord]:
        """根据用户ID获取诊断记录"""
        result = await session.execute(
            select(DiagnosisRecord)
            .where(DiagnosisRecord.user_id == user_id)
            .order_by(DiagnosisRecord.created_at.desc())
            .limit(limit)
        )
        return result.scalars().all()
```

### 3.4 数据同步和一致性

#### 3.4.1 数据同步策略

**Store和业务表的同步**：
- 健康档案信息：同时存储在Store和业务表中
  - Store用于快速检索和向量搜索
  - 业务表用于关系查询和统计分析
- 诊断历史：主要存储在业务表中，Store用于向量检索
  - 业务表存储完整的结构化数据
  - Store存储用于检索的关键信息（症状、诊断结果等）

**同步时机**：
- 实时同步：用户偏好、健康档案更新时立即同步
- 异步同步：诊断历史、用户模式定期同步（每日/每周）

#### 3.4.2 数据一致性保证

- **事务保证**：业务表操作使用数据库事务
- **最终一致性**：Store和业务表之间采用最终一致性模型
- **冲突解决**：以业务表为准，Store定期从业务表同步

## 4. 实现方案

### 4.1 实现阶段

#### 阶段1：基础长期记忆（已完成）
- ✅ Store基础设施（AsyncPostgresStore）
- ✅ 用户偏好和设置存储

#### 阶段2：健康档案存储（P0优先级）
- [ ] 健康档案数据模型设计
- [ ] 健康档案CRUD接口实现
- [ ] 健康档案Store同步机制
- [ ] 健康档案访问工具集成到智能体

#### 阶段3：用户习惯和模式（P1优先级）
- [ ] 用户模式识别和提取
- [ ] 用户模式存储和检索
- [ ] 用户模式应用（智能体主动提醒、预测意图等）

#### 阶段4：诊断历史和学习（P1优先级）
- [ ] 诊断历史数据模型设计
- [ ] 诊断历史存储和检索
- [ ] 诊断学习机制（基于历史记录优化建议）

#### 阶段5：用户反馈和评价（P2优先级）
- [ ] 反馈收集机制
- [ ] 反馈存储和分析
- [ ] 反馈应用（系统优化）

### 4.2 技术实现细节

#### 4.2.1 长期记忆管理器

创建统一的长期记忆管理器，封装所有长期记忆操作：

```python
# utils/memory/long_term_memory.py
class LongTermMemoryManager:
    """长期记忆管理器"""
    
    def __init__(self, store: AsyncPostgresStore, session_maker: AsyncSessionMaker):
        self.store = store
        self.session_maker = session_maker
        self.health_profile_crud = HealthProfileCRUD()
        self.diagnosis_record_crud = DiagnosisRecordCRUD()
    
    # 健康档案相关方法
    async def get_health_profile(self, user_id: str) -> Dict[str, Any]:
        """获取健康档案（优先从Store获取，如果不存在则从业务表获取并同步到Store）"""
        # 1. 尝试从Store获取
        namespace = ("health_profile", user_id)
        profile_store = await self.store.aget(namespace, "profile")
        if profile_store:
            return profile_store.value
        
        # 2. 从业务表获取
        async with self.session_maker() as session:
            profile = await self.health_profile_crud.get_by_user_id(session, user_id)
            if profile:
                profile_dict = {
                    "age": profile.age,
                    "gender": profile.gender,
                    "height": profile.height,
                    "weight": profile.weight,
                    "blood_type": profile.blood_type,
                    "allergies": profile.allergies,
                    "medical_history": profile.medical_history,
                    "family_history": profile.family_history,
                    "medications": profile.medications,
                    "baseline_bp_systolic": profile.baseline_bp_systolic,
                    "baseline_bp_diastolic": profile.baseline_bp_diastolic,
                    "health_goals": profile.health_goals,
                }
                # 同步到Store
                await self.store.aput(namespace, "profile", profile_dict)
                return profile_dict
        
        return {}
    
    async def update_health_profile(self, user_id: str, profile_data: Dict[str, Any]):
        """更新健康档案（同时更新Store和业务表）"""
        # 1. 更新业务表
        async with self.session_maker() as session:
            profile = await self.health_profile_crud.create_or_update(session, user_id, profile_data)
            profile_dict = {
                "age": profile.age,
                "gender": profile.gender,
                # ... 其他字段
            }
        
        # 2. 更新Store
        namespace = ("health_profile", user_id)
        await self.store.aput(namespace, "profile", profile_dict)
    
    # 诊断历史相关方法
    async def add_diagnosis_record(self, user_id: str, record_data: Dict[str, Any]):
        """添加诊断记录"""
        # 1. 保存到业务表
        async with self.session_maker() as session:
            record = await self.diagnosis_record_crud.create(session, record_data)
        
        # 2. 保存到Store（用于向量检索）
        namespace = ("diagnosis_history", user_id)
        searchable_data = {
            "symptoms": record_data.get("symptoms", []),
            "diagnosis": record_data.get("diagnosis", ""),
            "department": record_data.get("department", ""),
            "timestamp": record_data.get("created_at", "").isoformat(),
        }
        await self.store.aput(namespace, f"diagnosis_{record.id}", searchable_data)
    
    async def search_similar_diagnosis(self, user_id: str, query: str, limit: int = 5) -> List[Dict[str, Any]]:
        """搜索相似诊断记录"""
        namespace = ("diagnosis_history", user_id)
        results = await self.store.asearch(namespace, query, limit=limit)
        return [result.value for result in results]
```

#### 4.2.2 智能体集成

在各个智能体中集成长期记忆访问：

```python
# 诊断智能体中使用健康档案
async def diagnosis_agent_node(state: RouterState):
    user_id = state["user_id"]
    
    # 获取健康档案
    memory_manager = LongTermMemoryManager(store, session_maker)
    health_profile = await memory_manager.get_health_profile(user_id)
    
    # 在系统提示词中包含健康档案信息
    system_prompt = f"""
    患者基本信息：
    - 年龄：{health_profile.get('age', '未知')}
    - 性别：{health_profile.get('gender', '未知')}
    - 过敏史：{', '.join(health_profile.get('allergies', []))}
    - 既往病史：{', '.join(health_profile.get('medical_history', []))}
    - 常用药物：{', '.join(health_profile.get('medications', []))}
    
    请基于以上信息，结合患者当前症状，提供诊断建议。
    """
    
    # ... 继续诊断流程
```

### 4.3 数据隐私和安全

#### 4.3.1 数据加密

- **敏感信息加密**：健康档案中的敏感信息（如过敏史、既往病史）加密存储
- **传输加密**：使用HTTPS传输数据
- **访问控制**：基于用户ID的访问控制，确保用户只能访问自己的数据

#### 4.3.2 数据保留策略

- **用户偏好和设置**：永久保留，直到用户删除账户
- **健康档案**：永久保留，直到用户删除账户
- **诊断历史**：保留5年，之后归档或删除
- **用户反馈**：保留2年，用于系统优化

#### 4.3.3 数据删除

- **用户主动删除**：用户可以通过API删除自己的长期记忆数据
- **账户删除**：删除账户时，自动删除所有长期记忆数据
- **定期清理**：定期清理过期的诊断历史和反馈数据

## 5. 使用场景示例

### 5.1 场景1：诊断智能体使用健康档案

```
用户："我最近胸痛，帮我诊断一下"

诊断智能体：
1. 从长期记忆获取用户健康档案
   - 年龄：45岁
   - 性别：男
   - 既往病史：高血压
   - 常用药物：降压药
   
2. 结合健康档案和当前症状，提供诊断建议
   "根据您的健康档案，您有高血压病史，正在服用降压药。
   胸痛可能与心血管疾病相关，建议您..."
```

### 5.2 场景2：血压记录智能体主动提醒

```
系统检测到用户通常在每天早上8点测量血压

血压记录智能体（主动提醒）：
"您通常在每天早上8点测量血压，现在已经是8:30了，是否要记录今天的血压？"
```

### 5.3 场景3：复诊管理智能体推荐科室

```
用户："我想预约复诊"

复诊管理智能体：
1. 从长期记忆获取用户习惯
   - 常用科室：心内科
   - 常用医生：张医生
   
2. 推荐用户常用的科室和医生
   "您之前经常预约心内科的张医生，是否要预约同一科室？"
```

### 5.4 场景4：诊断智能体学习医生偏好

```
医生多次使用诊断智能体，系统学习到：
- 医生偏好详细的检查建议
- 医生偏好引用最新的医学指南
- 医生偏好提供多个诊断可能性

后续诊断时，诊断智能体自动调整回复风格，符合医生偏好。
```

## 6. 总结

### 6.1 设计要点

1. **分层存储**：使用Store存储非结构化数据，使用业务表存储结构化数据
2. **命名空间隔离**：按信息类型和用户ID组织数据，确保数据隔离
3. **统一接口**：提供统一的长期记忆访问接口，简化智能体集成
4. **数据同步**：Store和业务表之间保持同步，确保数据一致性
5. **隐私安全**：敏感信息加密存储，严格的访问控制

### 6.2 实施建议

1. **分阶段实施**：按照优先级分阶段实施，先实现P0优先级的功能
2. **向后兼容**：新功能不影响现有功能，保持向后兼容
3. **性能优化**：使用缓存机制，优化长期记忆访问性能
4. **监控和日志**：记录长期记忆访问日志，监控系统性能

### 6.3 未来扩展

1. **向量检索增强**：利用Store的向量检索能力，实现更智能的相似案例检索
2. **机器学习集成**：基于长期记忆数据，训练个性化模型
3. **跨用户学习**：在保护隐私的前提下，基于多用户数据优化系统
4. **实时学习**：实时更新用户模式，动态调整智能体行为

