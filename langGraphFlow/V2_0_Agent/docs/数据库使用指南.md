# 数据库使用指南

## 概述

本项目使用 PostgreSQL 数据库，并通过统一的连接池管理系统同时支持：
- **LangGraph**：使用 `psycopg_pool.AsyncConnectionPool` 进行状态管理和存储
- **SQLAlchemy ORM**：使用 SQLAlchemy 异步引擎进行业务数据操作

所有数据库连接池由 `utils.database.DatabasePool` 统一管理，确保配置一致和资源优化。

## 架构设计

### 连接池统一管理

```
┌─────────────────────────────────────────┐
│     utils.database.DatabasePool         │
│                                         │
│  ┌──────────────────────────────────┐  │
│  │  psycopg_pool.AsyncConnectionPool │  │
│  │  (LangGraph 使用)                  │  │
│  └──────────────────────────────────┘  │
│                                         │
│  ┌──────────────────────────────────┐  │
│  │  SQLAlchemy AsyncEngine           │  │
│  │  (业务数据操作)                    │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 配置一致性

两个连接池使用相同的配置参数：
- **最小连接数**：`Config.MIN_SIZE` (默认 5)
- **最大连接数**：`Config.MAX_SIZE` (默认 10)
- **时区设置**：`Config.DB_TIMEZONE` (默认 Asia/Shanghai)

## 使用方式

### 1. 应用初始化

在应用启动时（如 `01_backendServer.py`），统一初始化数据库连接池：

```python
from utils.database import get_db_pool

# 获取数据库连接池管理器（单例模式）
db_pool = get_db_pool()

# 初始化连接池（同时创建 LangGraph 和 SQLAlchemy 连接池）
langgraph_pool = await db_pool.create_pool()

# 使用 LangGraph 连接池
checkpointer = AsyncPostgresSaver(langgraph_pool)
store = AsyncPostgresStore(langgraph_pool)
```

### 2. LangGraph 使用

LangGraph 使用 `psycopg_pool` 连接池：

```python
from utils.database import get_db_pool
from langgraph.checkpoint.postgres.aio import AsyncPostgresSaver
from langgraph.store.postgres import AsyncPostgresStore

# 获取连接池
db_pool = get_db_pool()
pool = db_pool.pool  # 获取 LangGraph 连接池

# 创建 checkpointer 和 store
checkpointer = AsyncPostgresSaver(pool)
store = AsyncPostgresStore(pool)
```

### 3. SQLAlchemy ORM 使用

SQLAlchemy 使用统一管理的引擎：

```python
from utils.db import get_db_session, BloodPressureRecord
from sqlalchemy import select

# 方式1：使用 get_db_session（推荐，自动管理事务）
async with get_db_session() as session:
    query = select(BloodPressureRecord).where(
        BloodPressureRecord.user_id == "user123"
    )
    result = await session.execute(query)
    records = result.scalars().all()

# 方式2：使用 get_async_session（手动管理会话）
from utils.db import get_async_session

async_session_maker = get_async_session()
async with async_session_maker() as session:
    # 执行数据库操作
    await session.commit()
```

### 4. CRUD 操作

使用统一的 CRUD 基类：

```python
from utils.db import CRUDBase, BloodPressureRecord, get_db_session

# 创建 CRUD 实例
blood_pressure_crud = CRUDBase(BloodPressureRecord)

# 使用 CRUD 操作
async with get_db_session() as session:
    # 创建记录
    new_record = await blood_pressure_crud.create(session, {
        "user_id": "user123",
        "systolic": 120,
        "diastolic": 80
    })
    
    # 查询记录
    record = await blood_pressure_crud.get(session, id=new_record.id)
    
    # 更新记录
    await blood_pressure_crud.update(session, db_obj=record, obj_in={"systolic": 125})
    
    # 删除记录
    await blood_pressure_crud.delete(session, id=record.id)
```

## 连接池监控

### 健康检查接口

应用提供了数据库连接池健康检查接口：

```bash
# 检查数据库连接池状态
curl http://localhost:8001/health/db
```

返回示例：

```json
{
  "status": "ok",
  "langgraph_pool": "ok",
  "sqlalchemy_engine": "ok",
  "pool_stats": {
    "langgraph_pool": {
      "min_size": 5,
      "max_size": 10,
      "pool_size": 5,
      "available": 5,
      "waiting": 0
    },
    "sqlalchemy_engine": {
      "size": 5,
      "checked_in": 5,
      "checked_out": 0,
      "overflow": 0,
      "invalid": 0
    }
  }
}
```

### 程序内监控

```python
from utils.database import get_db_pool

db_pool = get_db_pool()
stats = db_pool.get_pool_stats()
print(f"连接池统计信息: {stats}")
```

## 配置说明

### 环境变量

在 `.env` 文件或环境变量中配置：

```bash
# 数据库连接URI
DB_URI=postgresql://postgres:password@localhost:5432/dbname?sslmode=disable

# 数据库时区
DB_TIMEZONE=Asia/Shanghai

# 连接池配置（可选，使用默认值）
# MIN_SIZE=5
# MAX_SIZE=10
```

### 配置参数

在 `utils.config.Config` 中定义：

- `DB_URI`：PostgreSQL 连接 URI
- `DB_TIMEZONE`：数据库时区（默认：Asia/Shanghai）
- `MIN_SIZE`：连接池最小连接数（默认：5）
- `MAX_SIZE`：连接池最大连接数（默认：10）

## 最佳实践

### 1. 连接池初始化

- ✅ **正确**：在应用启动时统一初始化
- ❌ **错误**：每次请求时创建新的连接池

```python
# ✅ 正确：在 lifespan 中初始化
@asynccontextmanager
async def lifespan(app: FastAPI):
    db_pool = get_db_pool()
    await db_pool.create_pool()
    yield
    await db_pool.close()
```

### 2. 会话管理

- ✅ **正确**：使用 `get_db_session()` 自动管理事务
- ❌ **错误**：手动管理会话但不处理异常

```python
# ✅ 正确：自动管理事务和异常
async with get_db_session() as session:
    # 数据库操作
    pass

# ❌ 错误：手动管理但可能遗漏异常处理
session = async_session_maker()
# 忘记 commit 或 rollback
```

### 3. 连接池关闭

- ✅ **正确**：在应用关闭时统一关闭
- ❌ **错误**：不关闭连接池导致资源泄漏

```python
# ✅ 正确：在 finally 块中关闭
finally:
    await db_pool.close()
```

## 故障排查

### 问题1：SQLAlchemy 引擎未初始化

**错误信息**：
```
RuntimeError: SQLAlchemy 引擎未初始化。请先调用 database.get_db_pool().create_pool() 初始化连接池。
```

**解决方案**：
确保在应用启动时调用了 `db_pool.create_pool()`。

### 问题2：连接池耗尽

**症状**：请求超时或连接错误

**解决方案**：
1. 检查连接池统计信息：`/health/db`
2. 增加 `MAX_SIZE` 配置
3. 检查是否有连接泄漏（未正确关闭会话）

### 问题3：时区不一致

**症状**：时间数据不正确

**解决方案**：
确保 `Config.DB_TIMEZONE` 设置正确，两个连接池都会自动配置时区。

## 性能优化建议

1. **连接池大小**：根据并发请求量调整 `MIN_SIZE` 和 `MAX_SIZE`
2. **连接复用**：使用连接池而非每次创建新连接
3. **事务管理**：合理使用事务，避免长时间占用连接
4. **查询优化**：使用索引和适当的查询条件

## 相关文档

- [SQLAlchemy 异步文档](https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html)
- [psycopg_pool 文档](https://www.psycopg.org/psycopg3/docs/api/pool.html)
- [LangGraph 检查点文档](https://langchain-ai.github.io/langgraph/how-tos/persistence/)

