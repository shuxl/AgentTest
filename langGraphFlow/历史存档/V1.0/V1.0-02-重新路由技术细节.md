# 重新路由技术细节解析

## 文档说明

本文档详细解答：在多智能体路由系统中，当用户在专门智能体中改变了意图时，如何实现重新路由的技术细节。

---

## 一、问题分析

### 1.1 核心问题

**场景**：
```
用户: "我想记录血压"
Agent: [路由到血压记录智能体] "请告诉我您的收缩压是多少？"
用户: "算了，我想预约复诊"
Agent: [需要重新路由到复诊智能体]
```

**关键问题**：
1. 当用户已经在专门智能体中时，如何检测到意图变化？
2. 如何实现从专门智能体返回到路由智能体？
3. 重新路由的实现机制是什么？

### 1.2 为什么说"可能"重新路由？

在之前的文档中，我说"可能"重新路由，是因为这取决于**具体的实现方案**：

- **方案一**：如果使用StateGraph，可以实现自动重新路由
- **方案二**：如果使用独立Agent，需要额外的机制才能重新路由

让我详细分析两种实现方案。

---

## 二、方案一：StateGraph + 条件路由（支持自动重新路由）

### 2.1 架构设计

**核心思想**：使用LangGraph的StateGraph，每次调用都经过路由节点判断。

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, List
from langchain_core.messages import BaseMessage

class RouterState(TypedDict):
    messages: List[BaseMessage]
    current_intent: Optional[str]
    current_agent: Optional[str]
    need_reroute: bool  # 是否需要重新路由

# 定义路由图
router_graph = StateGraph(RouterState)

# 添加节点
router_graph.add_node("router", router_node)  # 路由节点（每次调用都经过）
router_graph.add_node("blood_pressure_agent", blood_pressure_agent_node)
router_graph.add_node("appointment_agent", appointment_agent_node)
router_graph.add_node("doctor_assistant_agent", doctor_assistant_agent_node)

# 设置入口点：每次调用都从router节点开始
router_graph.set_entry_point("router")

# 添加条件边：根据意图路由到对应智能体
router_graph.add_conditional_edges(
    "router",
    route_decision,
    {
        "blood_pressure": "blood_pressure_agent",
        "appointment": "appointment_agent",
        "doctor_assistant": "doctor_assistant_agent",
        "continue": "router"  # 继续当前智能体，不切换
    }
)

# 添加回边：专门智能体执行完后，返回到router节点
router_graph.add_edge("blood_pressure_agent", "router")
router_graph.add_edge("appointment_agent", "router")
router_graph.add_edge("doctor_assistant_agent", "router")
```

### 2.2 路由节点实现

**关键**：每次调用时，路由节点都会检查当前意图和用户消息，判断是否需要重新路由。

```python
async def router_node(state: RouterState) -> RouterState:
    """
    路由节点：每次调用都会经过这个节点
    
    功能：
    1. 读取历史对话
    2. 识别用户意图（包括意图变化）
    3. 判断是否需要重新路由
    4. 更新状态
    """
    messages = state["messages"]
    current_intent = state.get("current_intent")
    current_agent = state.get("current_agent")
    
    # 获取最后一条用户消息
    last_user_message = None
    for msg in reversed(messages):
        if msg.type == "human":
            last_user_message = msg.content
            break
    
    if not last_user_message:
        return state
    
    # 调用意图识别工具
    intent_result = await identify_intent_tool(
        user_query=last_user_message,
        conversation_history=messages,
        current_intent=current_intent
    )
    
    new_intent = intent_result.intent_type
    confidence = intent_result.confidence
    
    # 判断是否需要重新路由
    need_reroute = False
    
    if current_intent and current_intent != new_intent:
        # 意图发生变化
        if confidence > 0.7:  # 置信度阈值
            need_reroute = True
            logger.info(f"检测到意图变化：{current_intent} → {new_intent}")
    
    # 更新状态
    state["current_intent"] = new_intent
    state["need_reroute"] = need_reroute
    
    return state

def route_decision(state: RouterState) -> str:
    """
    路由决策函数：决定下一步执行哪个节点
    """
    current_intent = state.get("current_intent")
    need_reroute = state.get("need_reroute", False)
    current_agent = state.get("current_agent")
    
    # 如果检测到需要重新路由，或者当前没有活跃的智能体
    if need_reroute or not current_agent:
        # 根据新意图路由
        if current_intent == "blood_pressure":
            state["current_agent"] = "blood_pressure_agent"
            return "blood_pressure"
        elif current_intent == "appointment":
            state["current_agent"] = "appointment_agent"
            return "appointment"
        elif current_intent == "doctor_assistant":
            state["current_agent"] = "doctor_assistant_agent"
            return "doctor_assistant"
        else:
            return "continue"
    
    # 如果不需要重新路由，继续当前智能体
    if current_agent == "blood_pressure_agent":
        return "blood_pressure"
    elif current_agent == "appointment_agent":
        return "appointment"
    elif current_agent == "doctor_assistant_agent":
        return "doctor_assistant"
    
    return "continue"
```

### 2.3 专门智能体节点实现

```python
async def blood_pressure_agent_node(state: RouterState) -> RouterState:
    """
    血压记录智能体节点
    
    注意：这个节点执行完后，会返回到router节点
    下次调用时，router节点会重新判断意图
    """
    messages = state["messages"]
    
    # 创建血压记录智能体
    agent = create_blood_pressure_agent()
    
    # 调用智能体（使用相同的thread_id）
    result = await agent.ainvoke(
        {"messages": messages},
        config={"configurable": {"thread_id": state.get("session_id")}}
    )
    
    # 更新消息列表
    state["messages"] = result["messages"]
    
    # 执行完后，返回到router节点
    # （通过图的边配置实现）
    
    return state
```

### 2.4 工作流程

**第1次调用**：
```
用户: "我想记录血压"
→ router_node: 识别意图="blood_pressure"
→ route_decision: 返回"blood_pressure"
→ blood_pressure_agent_node: 执行，返回"请告诉我您的收缩压是多少？"
→ 返回到router_node（通过边配置）
→ 保存状态：current_intent="blood_pressure", current_agent="blood_pressure_agent"
```

**第2次调用**：
```
用户: "120"
→ router_node: 识别意图="blood_pressure"（未变化）
→ route_decision: 检查need_reroute=False，返回"blood_pressure"（继续当前智能体）
→ blood_pressure_agent_node: 执行，返回"请告诉我您的舒张压是多少？"
→ 返回到router_node
→ 保存状态：current_intent="blood_pressure", current_agent="blood_pressure_agent"
```

**第3次调用**（用户改变意图）：
```
用户: "算了，我想预约复诊"
→ router_node: 识别意图="appointment"（意图变化！）
→ route_decision: 检查need_reroute=True，返回"appointment"（重新路由）
→ appointment_agent_node: 执行，返回"请告诉我您想预约哪个科室？"
→ 返回到router_node
→ 保存状态：current_intent="appointment", current_agent="appointment_agent"
```

### 2.5 优点和缺点

**优点**：
- ✅ **自动重新路由**：每次调用都经过router节点，自动检测意图变化
- ✅ **状态管理清晰**：所有状态都在RouterState中管理
- ✅ **易于扩展**：添加新智能体只需要添加节点和边

**缺点**：
- ❌ **性能开销**：每次调用都要经过router节点，增加一次意图识别
- ❌ **图结构复杂**：需要维护图的边和条件路由逻辑

---

## 三、方案二：独立Agent + 路由检查机制（需要额外实现）

### 3.1 架构设计

**核心思想**：专门智能体是独立的Agent，在API层添加路由检查机制。

```python
# API层实现
@app.post("/agent/invoke", response_model=AgentResponse)
async def invoke_agent(request: AgentRequest):
    session_id = request.session_id
    user_id = request.user_id
    
    # 1. 检查当前会话状态
    session = await session_manager.get_session(user_id, session_id)
    current_agent_type = session.get("current_agent_type")  # "blood_pressure", "appointment", etc.
    
    # 2. 检查是否需要重新路由
    need_reroute = await check_need_reroute(
        user_query=request.query,
        conversation_history=session.get("messages", []),
        current_agent_type=current_agent_type
    )
    
    if need_reroute:
        # 重新路由：识别新意图，切换到新的智能体
        new_intent = await identify_intent(request.query)
        new_agent_type = intent_to_agent_type(new_intent)
        
        # 更新会话状态
        await session_manager.update_session(
            user_id, session_id,
            current_agent_type=new_agent_type
        )
        
        # 调用新的智能体
        agent = get_agent_by_type(new_agent_type)
        result = await agent.ainvoke(
            {"messages": [{"role": "user", "content": request.query}]},
            config={"configurable": {"thread_id": session_id}}
        )
    else:
        # 继续当前智能体
        agent = get_agent_by_type(current_agent_type)
        result = await agent.ainvoke(
            {"messages": [{"role": "user", "content": request.query}]},
            config={"configurable": {"thread_id": session_id}}
        )
    
    return await process_agent_result(session_id, result, user_id)
```

### 3.2 路由检查函数

```python
async def check_need_reroute(
    user_query: str,
    conversation_history: List[dict],
    current_agent_type: Optional[str]
) -> bool:
    """
    检查是否需要重新路由
    
    策略：
    1. 如果当前没有活跃的智能体，需要路由
    2. 如果用户明确改变了意图，需要重新路由
    3. 如果用户回复无关内容，不重新路由（让当前智能体处理）
    """
    if not current_agent_type:
        return True
    
    # 调用意图识别
    intent_result = await identify_intent_tool(
        user_query=user_query,
        conversation_history=conversation_history
    )
    
    new_intent = intent_result.intent_type
    confidence = intent_result.confidence
    
    # 判断新意图是否与当前智能体匹配
    current_intent = agent_type_to_intent(current_agent_type)
    
    if new_intent != current_intent:
        # 意图不匹配
        if confidence > 0.7:  # 高置信度，确定需要重新路由
            return True
        elif confidence > 0.5:  # 中等置信度，可能是意图变化
            # 可以进一步检查：用户是否明确表达了新意图
            if has_explicit_intent_keywords(user_query, new_intent):
                return True
    
    return False

def agent_type_to_intent(agent_type: str) -> str:
    """将智能体类型转换为意图类型"""
    mapping = {
        "blood_pressure_agent": "blood_pressure",
        "appointment_agent": "appointment",
        "doctor_assistant_agent": "doctor_assistant"
    }
    return mapping.get(agent_type, "unknown")

def intent_to_agent_type(intent: str) -> str:
    """将意图类型转换为智能体类型"""
    mapping = {
        "blood_pressure": "blood_pressure_agent",
        "appointment": "appointment_agent",
        "doctor_assistant": "doctor_assistant_agent"
    }
    return mapping.get(intent, "unknown")

def has_explicit_intent_keywords(query: str, intent: str) -> bool:
    """检查查询中是否包含明确的意图关键词"""
    keywords = {
        "blood_pressure": ["血压", "测量", "记录血压"],
        "appointment": ["预约", "复诊", "挂号"],
        "doctor_assistant": ["医生", "助手", "咨询"]
    }
    
    intent_keywords = keywords.get(intent, [])
    return any(keyword in query for keyword in intent_keywords)
```

### 3.3 专门智能体实现

```python
# 每个专门智能体都是独立的Agent
def create_blood_pressure_agent():
    """创建血压记录智能体"""
    tools = create_blood_pressure_tools(store, user_id)
    agent = create_react_agent(
        model=llm,
        tools=tools,
        checkpointer=checkpointer
    )
    return agent

def get_agent_by_type(agent_type: str):
    """根据类型获取智能体实例"""
    agents = {
        "blood_pressure_agent": create_blood_pressure_agent(),
        "appointment_agent": create_appointment_agent(),
        "doctor_assistant_agent": create_doctor_assistant_agent()
    }
    return agents.get(agent_type)
```

### 3.4 工作流程

**第1次调用**：
```
用户: "我想记录血压"
→ check_need_reroute: current_agent_type=None，返回True
→ identify_intent: 识别意图="blood_pressure"
→ 调用blood_pressure_agent
→ 保存状态：current_agent_type="blood_pressure_agent"
```

**第2次调用**：
```
用户: "120"
→ check_need_reroute: current_agent_type="blood_pressure_agent"
  → identify_intent: 识别意图="blood_pressure"（未变化）
  → 返回False（不重新路由）
→ 继续调用blood_pressure_agent
→ 保存状态：current_agent_type="blood_pressure_agent"
```

**第3次调用**（用户改变意图）：
```
用户: "算了，我想预约复诊"
→ check_need_reroute: current_agent_type="blood_pressure_agent"
  → identify_intent: 识别意图="appointment"（意图变化！）
  → 检查：new_intent != current_intent，confidence > 0.7
  → 返回True（需要重新路由）
→ identify_intent: 确认新意图="appointment"
→ 调用appointment_agent
→ 保存状态：current_agent_type="appointment_agent"
```

### 3.5 优点和缺点

**优点**：
- ✅ **简单直接**：每个智能体独立实现，不需要复杂的图结构
- ✅ **灵活控制**：可以在API层灵活控制路由逻辑
- ✅ **性能较好**：不需要每次都经过router节点

**缺点**：
- ❌ **需要手动实现**：路由检查逻辑需要在API层实现
- ❌ **状态管理分散**：需要在Redis/数据库中维护当前智能体状态
- ❌ **容易遗漏**：如果路由检查逻辑不完善，可能无法正确重新路由

---

## 四、方案三：混合方案（推荐）

### 4.1 架构设计

**核心思想**：结合两种方案的优点，使用StateGraph但优化性能。

```python
from langgraph.graph import StateGraph, END

class RouterState(TypedDict):
    messages: List[BaseMessage]
    current_intent: Optional[str]
    current_agent: Optional[str]
    last_intent_check: Optional[float]  # 上次检查意图的时间戳

# 定义路由图
router_graph = StateGraph(RouterState)

# 添加节点
router_graph.add_node("intent_check", intent_check_node)  # 轻量级意图检查
router_graph.add_node("blood_pressure_agent", blood_pressure_agent_node)
router_graph.add_node("appointment_agent", appointment_agent_node)

# 设置入口点
router_graph.set_entry_point("intent_check")

# 条件路由：根据意图检查结果决定
router_graph.add_conditional_edges(
    "intent_check",
    route_decision,
    {
        "blood_pressure": "blood_pressure_agent",
        "appointment": "appointment_agent",
        "continue": "blood_pressure_agent"  # 继续当前智能体（需要从state中获取）
    }
)

# 专门智能体执行完后，返回到intent_check（但可以优化为不返回）
router_graph.add_edge("blood_pressure_agent", END)  # 执行完就结束
router_graph.add_edge("appointment_agent", END)
```

### 4.2 优化：智能意图检查

```python
async def intent_check_node(state: RouterState) -> RouterState:
    """
    轻量级意图检查节点
    
    优化策略：
    1. 如果当前有活跃的智能体，且用户消息很短，可能不需要重新路由
    2. 如果用户消息包含明确的意图关键词，才进行意图识别
    3. 使用缓存机制，避免重复识别
    """
    messages = state["messages"]
    current_agent = state.get("current_agent")
    
    # 获取最后一条用户消息
    last_user_message = None
    for msg in reversed(messages):
        if msg.type == "human":
            last_user_message = msg.content
            break
    
    if not last_user_message:
        return state
    
    # 优化：如果当前有活跃的智能体，且用户消息很短，可能不需要重新路由
    if current_agent and len(last_user_message) < 20:
        # 短消息，可能是继续当前任务
        # 检查是否包含明确的意图变化关键词
        if not has_intent_change_keywords(last_user_message):
            # 不包含意图变化关键词，可能不需要重新路由
            state["current_intent"] = state.get("current_intent")
            return state
    
    # 调用意图识别（可以缓存结果）
    intent_result = await identify_intent_tool(
        user_query=last_user_message,
        conversation_history=messages[-5:]  # 只使用最近5条消息
    )
    
    state["current_intent"] = intent_result.intent_type
    state["last_intent_check"] = time.time()
    
    return state

def has_intent_change_keywords(query: str) -> bool:
    """检查是否包含明确的意图变化关键词"""
    change_keywords = [
        "算了", "不想", "取消", "换个", "改一下",
        "我想", "我要", "帮我", "预约", "复诊", "挂号"
    ]
    return any(keyword in query for keyword in change_keywords)
```

### 4.3 工作流程

**第1次调用**：
```
用户: "我想记录血压"
→ intent_check_node: 识别意图="blood_pressure"
→ route_decision: 返回"blood_pressure"
→ blood_pressure_agent_node: 执行
→ END: 结束
```

**第2次调用**：
```
用户: "120"
→ intent_check_node: 
  - 检查：current_agent="blood_pressure_agent"，消息很短，不包含意图变化关键词
  - 跳过意图识别（优化）
  - 保持current_intent="blood_pressure"
→ route_decision: 返回"continue"（继续当前智能体）
→ blood_pressure_agent_node: 执行
→ END: 结束
```

**第3次调用**（用户改变意图）：
```
用户: "算了，我想预约复诊"
→ intent_check_node:
  - 检查：包含意图变化关键词"算了"、"我想"、"预约"
  - 调用意图识别：识别意图="appointment"
→ route_decision: 返回"appointment"（重新路由）
→ appointment_agent_node: 执行
→ END: 结束
```

### 4.4 优点

**优点**：
- ✅ **自动重新路由**：使用StateGraph自动管理路由
- ✅ **性能优化**：智能检查，避免不必要的意图识别
- ✅ **灵活控制**：可以根据消息内容决定是否检查意图

---

## 五、实现验证方案

### 5.1 测试场景

**测试用例1：正常流程（不改变意图）**
```
用户: "我想记录血压"
预期: 路由到血压记录智能体
用户: "120"
预期: 继续在血压记录智能体中，不重新路由
用户: "80"
预期: 继续在血压记录智能体中，不重新路由
```

**测试用例2：用户改变意图**
```
用户: "我想记录血压"
预期: 路由到血压记录智能体
用户: "120"
预期: 继续在血压记录智能体中
用户: "算了，我想预约复诊"
预期: 重新路由到复诊智能体
```

**测试用例3：用户模糊表达**
```
用户: "我想记录血压"
预期: 路由到血压记录智能体
用户: "算了"
预期: 需要进一步澄清，或者继续当前智能体（取决于实现）
用户: "我想预约复诊"
预期: 重新路由到复诊智能体
```

### 5.2 验证步骤

**步骤1：实现路由检查机制**
```python
# 根据选择的方案实现路由检查
# 方案一：实现StateGraph
# 方案二：实现API层的路由检查
# 方案三：实现混合方案
```

**步骤2：添加日志记录**
```python
logger.info(f"当前智能体: {current_agent_type}")
logger.info(f"用户消息: {user_query}")
logger.info(f"识别意图: {new_intent}, 置信度: {confidence}")
logger.info(f"是否需要重新路由: {need_reroute}")
```

**步骤3：运行测试用例**
```bash
# 使用测试脚本或手动测试
python test_reroute.py
```

**步骤4：检查checkpoint状态**
```python
# 检查checkpoint中的对话历史
checkpoint = await checkpointer.aget(
    {"configurable": {"thread_id": session_id}}
)
print(f"对话历史: {checkpoint['channel_values']['messages']}")
```

### 5.3 验证指标

1. **重新路由准确性**
   - 用户明确改变意图时，是否能正确识别并重新路由
   - 用户没有改变意图时，是否不会错误地重新路由

2. **性能影响**
   - 重新路由的延迟是否可接受
   - 意图识别的开销是否合理

3. **用户体验**
   - 重新路由是否自然流畅
   - 用户是否感知到智能体切换

---

## 六、推荐方案

### 6.1 方案选择建议

**推荐使用方案三（混合方案）**，原因：

1. **自动重新路由**：使用StateGraph自动管理路由逻辑
2. **性能优化**：智能检查，避免不必要的意图识别
3. **易于维护**：路由逻辑集中管理，易于调试和扩展

### 6.2 实施建议

1. **第一阶段**：实现方案二（独立Agent + 路由检查）
   - 简单直接，快速验证
   - 可以先实现基本功能

2. **第二阶段**：优化为方案三（混合方案）
   - 使用StateGraph优化路由逻辑
   - 添加智能检查机制
   - 优化性能

### 6.3 关键代码位置

```python
# 1. 路由检查逻辑
# 文件：utils/router.py
async def check_need_reroute(...) -> bool:
    """检查是否需要重新路由"""
    pass

# 2. 意图识别工具
# 文件：utils/tools/router_tools.py
@tool("identify_intent", description="识别用户意图")
async def identify_intent(...) -> IntentResult:
    """识别用户意图"""
    pass

# 3. API层路由逻辑
# 文件：01_backendServer.py
@app.post("/agent/invoke")
async def invoke_agent(request: AgentRequest):
    """调用智能体，包含路由检查"""
    # 检查是否需要重新路由
    # 调用对应的智能体
    pass
```

---

## 七、总结

### 7.1 核心结论

**重新路由是完全可以实现的**，关键取决于实现方案：

1. **方案一（StateGraph）**：✅ 完全支持自动重新路由
2. **方案二（独立Agent）**：✅ 需要手动实现路由检查机制
3. **方案三（混合方案）**：✅ 推荐，结合两者优点

### 7.2 技术要点

1. **意图检测**：每次调用时检查用户意图是否变化
2. **状态管理**：维护当前活跃的智能体状态
3. **路由决策**：根据意图变化决定是否重新路由
4. **性能优化**：智能检查，避免不必要的意图识别

### 7.3 验证TODO

建议在代码实现后验证以下场景：

- [ ] 正常流程：用户在专门智能体中完成任务，不改变意图
- [ ] 重新路由：用户在专门智能体中改变意图，能正确重新路由
- [ ] 模糊表达：用户模糊表达意图变化，能正确处理
- [ ] 性能测试：重新路由的延迟和性能影响

---

*文档版本：v1.0*  
*更新时间：2025年11月*  
*作者：@舒小龙*

