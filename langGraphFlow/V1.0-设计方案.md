# 多智能体路由系统设计方案

## 一、需求分析

### 1.1 业务背景

当前系统（0701版本）实现了一个单一的血压记录智能体，能够通过多轮对话引导用户完成血压数据的收集和记录。然而，在实际的医疗健康业务场景中，用户的需求是多样化的：

1. **血压数据收集**：用户需要记录和管理血压数据
2. **复诊管理**：用户需要预约复诊、查询复诊记录、管理复诊提醒
3. **医生助手**：医生需要助手来处理日常咨询、病历查询、处方管理等
4. **其他健康服务**：随着业务发展，可能需要添加更多专门的智能体

### 1.2 核心需求

#### 1.2.1 多智能体架构需求

1. **前置路由智能体（Intent Router Agent）**
   - 负责识别用户的真实意图
   - 引导用户明确表达需求
   - 根据意图将任务路由到对应的专门智能体
   - 处理意图不明确或需要澄清的场景

2. **专门智能体（Specialized Agents）**
   - **血压记录智能体**：继承0701版本的功能，专门处理血压数据收集和管理
   - **复诊管理智能体**：处理复诊预约、查询、提醒等业务
   - **医生助手智能体**：协助医生处理日常咨询、病历管理、处方管理等
   - **可扩展架构**：支持未来添加更多专门智能体（如：用药提醒、健康咨询、体检预约等）

#### 1.2.2 路由机制需求

1. **意图识别**
   - 支持自然语言理解，识别用户意图
   - 支持多轮对话澄清意图
   - 处理复合意图（用户同时提及多个需求）

2. **智能路由**
   - 根据识别出的意图，自动路由到对应的专门智能体
   - 支持意图切换（用户在对话过程中改变意图）
   - 支持并发处理多个意图（如果业务需要）

3. **上下文管理**
   - 每个智能体维护独立的对话上下文
   - 路由智能体维护全局上下文
   - 支持在智能体之间传递必要的上下文信息

#### 1.2.3 用户体验需求

1. **无缝切换**
   - 用户感知不到智能体切换的过程
   - 对话流程自然流畅
   - 无需重新说明已提供的信息

2. **意图澄清**
   - 当意图不明确时，友好地引导用户说明
   - 提供选项让用户选择（如："您是想记录血压，还是预约复诊？"）

3. **统一入口**
   - 用户只需要与一个入口对话
   - 系统自动处理路由和切换

### 1.3 功能需求

#### 1.3.1 路由智能体功能

1. **意图识别工具**
   - `identify_intent`：识别用户意图，返回意图类型和置信度
   - `clarify_intent`：当意图不明确时，生成澄清问题

2. **路由决策**
   - 根据意图类型选择对应的专门智能体
   - 处理意图切换场景
   - 记录路由历史

#### 1.3.2 血压记录智能体功能

- 继承0701版本的所有功能
- 记录血压数据
- 查询历史血压记录
- 更新血压记录
- 查询血压统计信息

#### 1.3.3 复诊管理智能体功能

1. **复诊预约**
   - 引导用户选择复诊科室和医生
   - 选择复诊时间
   - 确认预约信息并保存

2. **复诊查询**
   - 查询用户的复诊预约记录
   - 查询复诊历史
   - 查询复诊状态

3. **复诊提醒**
   - 设置复诊提醒
   - 查询复诊提醒设置
   - 管理复诊提醒

#### 1.3.4 医生助手智能体功能

1. **日常咨询处理**
   - 处理患者的常见咨询问题
   - 提供医疗建议（基于规则和知识库）
   - 引导患者到合适的科室

2. **病历管理**
   - 查询患者病历
   - 更新病历信息
   - 管理病历记录

3. **处方管理**
   - 查询患者处方
   - 开具处方
   - 管理处方记录

### 1.4 非功能需求

1. **性能要求**
   - 路由决策时间 < 500ms
   - 智能体切换时间 < 1s
   - 支持并发用户会话

2. **可靠性要求**
   - 路由准确率 > 90%
   - 智能体切换不丢失上下文
   - 异常情况下的优雅降级

3. **可扩展性要求**
   - 易于添加新的专门智能体
   - 支持动态配置智能体
   - 不影响现有智能体的功能

## 二、总体技术方案

### 2.1 架构设计

#### 2.1.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                   用户请求入口                            │
│              (FastAPI Backend Server)                    │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              路由智能体 (Router Agent)                   │
│  - 意图识别                                             │
│  - 意图澄清                                             │
│  - 路由决策                                             │
└─────┬───────────┬───────────┬───────────┬──────────────┘
      │           │           │           │
      ▼           ▼           ▼           ▼
┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
│ 血压记录 │ │ 复诊管理 │ │ 医生助手 │ │ 其他智能体│
│ 智能体   │ │ 智能体   │ │ 智能体   │ │ (可扩展) │
└──────────┘ └──────────┘ └──────────┘ └──────────┘
      │           │           │           │
      └───────────┴───────────┴───────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              基础设施层                                   │
│  - PostgreSQL (短期记忆 + 长期记忆)                      │
│  - Redis (会话管理)                                      │
│  - LangGraph (Agent框架)                                │
└─────────────────────────────────────────────────────────┘
```

#### 2.1.2 核心组件

1. **路由智能体（Router Agent）**
   - 基于LangGraph构建
   - 使用专门的意图识别工具
   - 维护全局对话上下文
   - 负责智能体间的协调

2. **专门智能体（Specialized Agents）**
   - 每个智能体独立运行
   - 使用独立的工具集
   - 维护独立的对话上下文
   - 通过统一的接口与路由智能体交互

3. **会话管理**
   - 每个用户会话维护一个路由智能体实例
   - 专门智能体按需创建和销毁
   - 通过session_id关联所有智能体的上下文

### 2.2 技术选型

#### 2.2.1 框架和库

- **LangGraph**：用于构建路由智能体和专门智能体
- **LangChain**：提供LLM调用和工具支持
- **FastAPI**：后端API服务框架
- **PostgreSQL**：短期记忆（checkpointer）和长期记忆（store）
- **Redis**：会话状态管理

#### 2.2.2 路由机制实现方案

**方案一：LangGraph State Graph + 条件路由**

使用LangGraph的StateGraph和条件边实现路由：

```python
from langgraph.graph import StateGraph, END

# 定义路由图
router_graph = StateGraph(RouterState)

# 添加节点
router_graph.add_node("identify_intent", identify_intent_node)
router_graph.add_node("clarify_intent", clarify_intent_node)
router_graph.add_node("blood_pressure_agent", blood_pressure_agent_node)
router_graph.add_node("appointment_agent", appointment_agent_node)
router_graph.add_node("doctor_assistant_agent", doctor_assistant_agent_node)

# 添加边
router_graph.add_edge("identify_intent", route_to_specialized_agent)
router_graph.add_conditional_edges(
    "identify_intent",
    route_decision,
    {
        "blood_pressure": "blood_pressure_agent",
        "appointment": "appointment_agent",
        "doctor_assistant": "doctor_assistant_agent",
        "unclear": "clarify_intent"
    }
)
```

**方案二：独立Agent + 消息传递**

每个智能体独立运行，通过消息传递实现路由：

```python
# 路由智能体识别意图后，调用对应的专门智能体
if intent == "blood_pressure":
    result = await blood_pressure_agent.ainvoke(
        {"messages": messages},
        config={"configurable": {"thread_id": f"{session_id}_bp"}}
    )
```

**推荐方案一**，因为：
- 更符合LangGraph的设计理念
- 状态管理更清晰
- 更容易扩展和维护

### 2.3 数据模型设计

#### 2.3.1 意图识别结果

```python
class IntentResult(BaseModel):
    intent_type: str  # "blood_pressure", "appointment", "doctor_assistant", "unclear"
    confidence: float  # 0.0-1.0
    entities: Dict[str, Any]  # 提取的实体信息
    need_clarification: bool  # 是否需要澄清
```

#### 2.3.2 路由状态

```python
class RouterState(TypedDict):
    messages: List[BaseMessage]  # 消息列表
    current_intent: Optional[str]  # 当前意图
    current_agent: Optional[str]  # 当前活跃的智能体
    intent_history: List[IntentResult]  # 意图历史
    context: Dict[str, Any]  # 全局上下文
```

#### 2.3.3 专门智能体状态

每个专门智能体维护自己的状态：

```python
class SpecializedAgentState(TypedDict):
    messages: List[BaseMessage]
    agent_type: str  # "blood_pressure", "appointment", etc.
    session_id: str
    user_id: str
```

### 2.4 工具设计

#### 2.4.1 路由智能体工具

1. **identify_intent工具**
   ```python
   @tool("identify_intent", description="识别用户的真实意图")
   async def identify_intent(
       user_query: str,
       conversation_history: List[str] = None
   ) -> IntentResult:
       """
       识别用户意图
       
       Args:
           user_query: 用户当前查询
           conversation_history: 对话历史（可选）
       
       Returns:
           IntentResult: 意图识别结果
       """
   ```

2. **route_to_agent工具**
   ```python
   @tool("route_to_agent", description="将任务路由到指定的专门智能体")
   async def route_to_agent(
       intent_type: str,
       user_query: str,
       context: Dict[str, Any] = None
   ) -> str:
       """
       路由到专门智能体
       
       Args:
           intent_type: 意图类型
           user_query: 用户查询
           context: 上下文信息
       
       Returns:
           str: 路由结果消息
       """
   ```

#### 2.4.2 专门智能体工具

每个专门智能体有自己特定的工具集：

- **血压记录智能体**：继承0701版本的工具（record_blood_pressure, query_blood_pressure, update_blood_pressure, info）
- **复诊管理智能体**：appointment_booking, query_appointment, update_appointment, set_reminder等
- **医生助手智能体**：query_patient_record, update_patient_record, prescribe_medicine, query_prescription等

### 2.5 系统提示词设计

#### 2.5.1 路由智能体系统提示词

```
你是一个智能路由助手，负责识别用户的真实意图并将任务路由到对应的专门智能体。

你的核心任务是：
1. 识别用户的真实意图（血压记录、复诊管理、医生助手等）
2. 当意图不明确时，友好地引导用户说明
3. 根据意图将任务路由到对应的专门智能体
4. 管理用户在不同智能体之间的切换

支持的意图类型：
- blood_pressure: 用户想要记录、查询或管理血压数据
- appointment: 用户想要预约、查询或管理复诊
- doctor_assistant: 医生需要助手处理咨询、病历、处方等
- unclear: 意图不明确，需要进一步澄清

路由策略：
- 如果意图明确且置信度高（>0.8），直接路由到对应智能体
- 如果意图不明确（置信度<0.8），使用clarify_intent工具生成澄清问题
- 如果用户改变了意图，记录意图切换并路由到新智能体
- 如果用户同时提及多个意图，按优先级处理（优先级：doctor_assistant > appointment > blood_pressure）

记住：始终以用户为中心，提供自然流畅的对话体验。
```

#### 2.5.2 专门智能体系统提示词

每个专门智能体有自己特定的系统提示词：

- **血压记录智能体**：继承0701版本的系统提示词
- **复诊管理智能体**：针对复诊业务的专业提示词
- **医生助手智能体**：针对医生助手业务的专业提示词

### 2.6 实现方案

#### 2.6.1 项目结构

```
0702_ReActAgentMultiAgentRouterTest/
├── 01_backendServer.py          # 后端API服务
├── 02_frontendServer.py          # 前端客户端
├── README.md                     # 项目说明文档
├── utils/
│   ├── __init__.py
│   ├── config.py                # 配置管理
│   ├── llms.py                  # LLM初始化
│   ├── router.py                 # 路由智能体实现
│   ├── agents/
│   │   ├── __init__.py
│   │   ├── blood_pressure_agent.py    # 血压记录智能体
│   │   ├── appointment_agent.py       # 复诊管理智能体
│   │   └── doctor_assistant_agent.py  # 医生助手智能体
│   └── tools/
│       ├── __init__.py
│       ├── router_tools.py             # 路由智能体工具
│       ├── blood_pressure_tools.py     # 血压记录工具（复用0701）
│       ├── appointment_tools.py        # 复诊管理工具
│       └── doctor_assistant_tools.py   # 医生助手工具
└── logfile/                     # 日志文件目录
```

#### 2.6.2 核心实现流程

1. **用户请求处理**
   ```
   用户请求 → FastAPI接口 → 路由智能体 → 意图识别 → 路由决策 → 专门智能体 → 返回结果
   ```

2. **路由智能体执行流程**
   ```
   接收用户消息 → identify_intent工具 → 判断意图置信度
   ├─ 高置信度 → route_to_agent工具 → 调用专门智能体 → 返回结果
   └─ 低置信度 → clarify_intent工具 → 生成澄清问题 → 等待用户回复 → 重新识别意图
   ```

3. **专门智能体执行流程**
   ```
   接收路由请求 → 创建或复用智能体实例 → 执行任务 → 返回结果 → 路由智能体 → 用户
   ```

#### 2.6.3 会话管理

- **路由智能体会话**：使用 `{session_id}` 作为thread_id
- **专门智能体会话**：使用 `{session_id}_{agent_type}` 作为thread_id
- **状态同步**：路由智能体维护全局状态，专门智能体维护局部状态

### 2.7 扩展性设计

#### 2.7.1 添加新智能体

1. **创建智能体类**
   ```python
   # utils/agents/new_agent.py
   class NewAgent:
       def __init__(self, llm, tools, checkpointer, store):
           self.agent = create_react_agent(...)
       
       async def invoke(self, messages, config):
           return await self.agent.ainvoke(messages, config)
   ```

2. **创建工具集**
   ```python
   # utils/tools/new_agent_tools.py
   def create_new_agent_tools(store, user_id):
       # 定义工具
       return [tool1, tool2, ...]
   ```

3. **注册到路由系统**
   ```python
   # utils/router.py
   INTENT_TO_AGENT = {
       "blood_pressure": BloodPressureAgent,
       "appointment": AppointmentAgent,
       "doctor_assistant": DoctorAssistantAgent,
       "new_agent": NewAgent  # 注册新智能体
   }
   ```

#### 2.7.2 配置化路由规则

支持通过配置文件定义路由规则：

```python
# config/routing_rules.yaml
routing_rules:
  - intent: "blood_pressure"
    keywords: ["血压", "测量", "记录"]
    agent: "blood_pressure_agent"
    priority: 1
  
  - intent: "appointment"
    keywords: ["复诊", "预约", "挂号"]
    agent: "appointment_agent"
    priority: 2
```

### 2.8 性能优化

1. **智能体实例复用**
   - 为每个用户会话维护智能体实例池
   - 智能体实例按需创建，完成后复用

2. **异步处理**
   - 路由决策异步执行
   - 专门智能体调用异步执行

3. **缓存机制**
   - 意图识别结果缓存
   - 常用查询结果缓存

### 2.9 错误处理

1. **路由失败**
   - 意图识别失败时，降级到通用智能体
   - 专门智能体不可用时，返回友好的错误提示

2. **上下文丢失**
   - 记录智能体切换历史
   - 支持上下文恢复

3. **异常处理**
   - 捕获所有异常并记录日志
   - 返回友好的错误提示给用户

## 三、实施计划

### 3.1 阶段一：基础架构搭建（预计2-3天）

1. 创建项目结构和基础代码
2. 实现路由智能体框架
3. 实现意图识别工具
4. 实现路由决策逻辑

### 3.2 阶段二：专门智能体实现（预计3-4天）

1. 复用0701版本的血压记录智能体
2. 实现复诊管理智能体（基础功能）
3. 实现医生助手智能体（基础功能）
4. 实现智能体间的切换机制

### 3.3 阶段三：集成和测试（预计2-3天）

1. 集成测试路由功能
2. 端到端测试各个智能体
3. 性能测试和优化
4. 文档完善

### 3.4 阶段四：优化和扩展（持续）

1. 优化意图识别准确率
2. 添加更多专门智能体
3. 优化用户体验
4. 性能持续优化

## 四、风险评估

### 4.1 技术风险

1. **意图识别准确率**
   - 风险：意图识别不准确导致路由错误
   - 缓解：使用置信度阈值，低置信度时进行澄清

2. **上下文管理复杂**
   - 风险：多个智能体间上下文切换可能丢失信息
   - 缓解：设计清晰的状态管理机制，记录上下文切换历史

3. **性能问题**
   - 风险：多智能体系统可能影响响应时间
   - 缓解：使用异步处理，智能体实例复用，缓存机制

### 4.2 业务风险

1. **用户体验**
   - 风险：智能体切换可能让用户感到困惑
   - 缓解：无缝切换设计，清晰的提示信息

2. **扩展性**
   - 风险：未来添加新智能体可能影响现有系统
   - 缓解：模块化设计，清晰的接口定义

## 五、总结

本设计方案基于LangGraph框架，实现了一个多智能体路由系统，具有以下特点：

1. **清晰的架构**：路由智能体 + 专门智能体的两层架构
2. **灵活的扩展**：易于添加新的专门智能体
3. **良好的用户体验**：无缝切换，自然对话
4. **高性能**：异步处理，智能体复用，缓存机制

通过这个系统，我们可以：
- 统一管理多个业务智能体
- 提供更好的用户体验
- 支持业务快速扩展
- 保持代码的可维护性

---

*设计方案文档版本：v1.0*  
*设计时间：2025年11月*  
*作者：@舒小龙*

