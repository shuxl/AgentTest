# 多智能体路由系统设计方案 V2.0

## 一、需求分析

### 1.1 业务背景

当前系统（0701版本）实现了一个单一的血压记录智能体，能够通过多轮对话引导用户完成血压数据的收集和记录。然而，在实际的医疗健康业务场景中，用户的需求是多样化的：

1. **血压数据收集**：用户需要记录和管理血压数据
2. **复诊管理**：用户需要预约复诊、查询复诊记录、管理复诊提醒
3. **医生助手**：医生需要助手来处理日常咨询、病历查询、处方管理等
4. **其他健康服务**：随着业务发展，可能需要添加更多专门的智能体

### 1.2 核心需求

#### 1.2.1 多智能体架构需求

1. **前置路由智能体（Intent Router Agent）**
   - 负责识别用户的真实意图
   - 引导用户明确表达需求
   - 根据意图将任务路由到对应的专门智能体
   - 处理意图不明确或需要澄清的场景

2. **专门智能体（Specialized Agents）**
   - **血压记录智能体**：继承0701版本的功能，专门处理血压数据收集和管理
   - **复诊管理智能体**：处理复诊预约、查询、提醒等业务
   - **医生助手智能体**：协助医生处理日常咨询、病历管理、处方管理等
   - **可扩展架构**：支持未来添加更多专门智能体（如：用药提醒、健康咨询、体检预约等）

#### 1.2.2 路由机制需求

1. **意图识别**
   - 支持自然语言理解，识别用户意图
   - 支持多轮对话澄清意图
   - 处理复合意图（用户同时提及多个需求）

2. **智能路由**
   - 根据识别出的意图，自动路由到对应的专门智能体
   - 支持意图切换（用户在对话过程中改变意图）
   - 自动检测意图变化并重新路由

3. **上下文管理**
   - 每个智能体维护独立的对话上下文
   - 路由智能体维护全局上下文
   - 支持在智能体之间传递必要的上下文信息

#### 1.2.3 用户体验需求

1. **无缝切换**
   - 用户感知不到智能体切换的过程
   - 对话流程自然流畅
   - 无需重新说明已提供的信息

2. **意图澄清**
   - 当意图不明确时，友好地引导用户说明
   - 提供选项让用户选择（如："您是想记录血压，还是预约复诊？"）

3. **统一入口**
   - 用户只需要与一个入口对话
   - 系统自动处理路由和切换

### 1.3 功能需求

#### 1.3.1 路由智能体功能

1. **意图识别工具**
   - `identify_intent`：识别用户意图，返回意图类型和置信度
   - `clarify_intent`：当意图不明确时，生成澄清问题

2. **路由决策**
   - 根据意图类型选择对应的专门智能体
   - 自动处理意图切换场景
   - 记录路由历史

#### 1.3.2 血压记录智能体功能

- 继承0701版本的所有功能
- 记录血压数据
- 查询历史血压记录
- 更新血压记录
- 查询血压统计信息

#### 1.3.3 复诊管理智能体功能

1. **复诊预约**
   - 引导用户选择复诊科室和医生
   - 选择复诊时间
   - 确认预约信息并保存

2. **复诊查询**
   - 查询用户的复诊预约记录
   - 查询复诊历史
   - 查询复诊状态

3. **复诊提醒**
   - 设置复诊提醒
   - 查询复诊提醒设置
   - 管理复诊提醒

#### 1.3.4 医生助手智能体功能

1. **日常咨询处理**
   - 处理患者的常见咨询问题
   - 提供医疗建议（基于规则和知识库）
   - 引导患者到合适的科室

2. **病历管理**
   - 查询患者病历
   - 更新病历信息
   - 管理病历记录

3. **处方管理**
   - 查询患者处方
   - 开具处方
   - 管理处方记录

### 1.4 非功能需求

1. **性能要求**
   - 路由决策时间 < 500ms
   - 智能体切换时间 < 1s
   - 支持并发用户会话

2. **可靠性要求**
   - 路由准确率 > 90%
   - 智能体切换不丢失上下文
   - 异常情况下的优雅降级

3. **可扩展性要求**
   - 易于添加新的专门智能体
   - 支持动态配置智能体
   - 不影响现有智能体的功能

## 二、总体技术方案

### 2.1 架构设计

#### 2.1.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                   用户请求入口                            │
│              (FastAPI Backend Server)                    │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              路由智能体 (Router Agent)                   │
│  基于StateGraph实现，每次调用都经过路由节点               │
│  - 意图识别                                             │
│  - 意图澄清                                             │
│  - 路由决策                                             │
└─────┬───────────┬───────────┬───────────┬──────────────┘
      │           │           │           │
      ▼           ▼           ▼           ▼
┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
│ 血压记录 │ │ 复诊管理 │ │ 医生助手 │ │ 其他智能体│
│ 智能体   │ │ 智能体   │ │ 智能体   │ │ (可扩展) │
└─────┬────┘ └─────┬────┘ └─────┬────┘ └─────┬────┘
      │           │           │           │
      └───────────┴───────────┴───────────┘
                     │
                     ▼
          ┌──────────────────────┐
          │   返回到路由节点      │
          │  (通过StateGraph边)  │
          └──────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              基础设施层                                   │
│  - PostgreSQL (短期记忆 + 长期记忆)                      │
│  - Redis (会话管理)                                      │
│  - LangGraph (Agent框架)                                │
└─────────────────────────────────────────────────────────┘
```

#### 2.1.2 核心组件

1. **路由智能体（Router Agent）**
   - 基于LangGraph StateGraph构建
   - 每次调用都经过路由节点，自动检测意图变化
   - 使用专门的意图识别工具
   - 维护全局对话上下文
   - 负责智能体间的协调和重新路由

2. **专门智能体（Specialized Agents）**
   - 每个智能体作为StateGraph中的一个节点
   - 使用独立的工具集
   - 维护独立的对话上下文
   - 执行完后返回到路由节点，等待下次调用

3. **会话管理**
   - 每个用户会话使用一个StateGraph实例
   - 通过`session_id`作为`thread_id`关联所有智能体的上下文
   - 状态自动保存在checkpointer中

### 2.2 技术选型

#### 2.2.1 框架和库

- **LangGraph**：用于构建路由智能体和专门智能体
- **LangChain**：提供LLM调用和工具支持
- **FastAPI**：后端API服务框架
- **PostgreSQL**：短期记忆（checkpointer）和长期记忆（store）
- **Redis**：会话状态管理

#### 2.2.2 路由机制实现方案

**采用方案：LangGraph State Graph + 条件路由**

使用LangGraph的StateGraph和条件边实现路由，每次调用都经过路由节点，自动检测意图变化并重新路由：

```python
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Optional
from langchain_core.messages import BaseMessage

class RouterState(TypedDict):
    messages: List[BaseMessage]  # 消息列表
    current_intent: Optional[str]  # 当前意图
    current_agent: Optional[str]  # 当前活跃的智能体
    need_reroute: bool  # 是否需要重新路由
    session_id: str  # 会话ID

# 定义路由图
router_graph = StateGraph(RouterState)

# 添加节点
router_graph.add_node("router", router_node)  # 路由节点（每次调用都经过）
router_graph.add_node("clarify_intent", clarify_intent_node)
router_graph.add_node("blood_pressure_agent", blood_pressure_agent_node)
router_graph.add_node("appointment_agent", appointment_agent_node)
router_graph.add_node("doctor_assistant_agent", doctor_assistant_agent_node)

# 设置入口点：每次调用都从router节点开始
router_graph.set_entry_point("router")

# 添加条件边：根据意图路由到对应智能体
router_graph.add_conditional_edges(
    "router",
    route_decision,
    {
        "blood_pressure": "blood_pressure_agent",
        "appointment": "appointment_agent",
        "doctor_assistant": "doctor_assistant_agent",
        "unclear": "clarify_intent"
    }
)

# 添加回边：专门智能体执行完后，返回到router节点
router_graph.add_edge("blood_pressure_agent", "router")
router_graph.add_edge("appointment_agent", "router")
router_graph.add_edge("doctor_assistant_agent", "router")
router_graph.add_edge("clarify_intent", "router")

# 编译图
agent = router_graph.compile(checkpointer=checkpointer)
```

**方案优势**：
- ✅ **自动重新路由**：每次调用都经过router节点，自动检测意图变化
- ✅ **状态管理清晰**：所有状态都在RouterState中管理
- ✅ **易于扩展**：添加新智能体只需要添加节点和边
- ✅ **符合LangGraph设计理念**：使用状态图管理复杂流程

### 2.3 数据模型设计

#### 2.3.1 意图识别结果

```python
from pydantic import BaseModel
from typing import Dict, Any

class IntentResult(BaseModel):
    intent_type: str  # "blood_pressure", "appointment", "doctor_assistant", "unclear"
    confidence: float  # 0.0-1.0
    entities: Dict[str, Any]  # 提取的实体信息
    need_clarification: bool  # 是否需要澄清
```

#### 2.3.2 路由状态

```python
from typing import TypedDict, List, Optional
from langchain_core.messages import BaseMessage

class RouterState(TypedDict):
    messages: List[BaseMessage]  # 消息列表
    current_intent: Optional[str]  # 当前意图
    current_agent: Optional[str]  # 当前活跃的智能体
    need_reroute: bool  # 是否需要重新路由
    session_id: str  # 会话ID
    user_id: str  # 用户ID
```

### 2.4 工具设计

#### 2.4.1 路由智能体工具

1. **identify_intent工具**
   ```python
   @tool("identify_intent", description="识别用户的真实意图")
   async def identify_intent(
       user_query: str,
       conversation_history: List[str] = None,
       current_intent: Optional[str] = None
   ) -> IntentResult:
       """
       识别用户意图
       
       Args:
           user_query: 用户当前查询
           conversation_history: 对话历史（可选）
           current_intent: 当前意图（可选，用于检测意图变化）
       
       Returns:
           IntentResult: 意图识别结果
       """
   ```

2. **clarify_intent工具**
   ```python
   @tool("clarify_intent", description="当意图不明确时，生成澄清问题")
   async def clarify_intent(
       user_query: str,
       possible_intents: List[str]
   ) -> str:
       """
       生成澄清问题
       
       Args:
           user_query: 用户当前查询
           possible_intents: 可能的意图列表
       
       Returns:
           str: 澄清问题
       """
   ```

#### 2.4.2 专门智能体工具

每个专门智能体有自己特定的工具集：

- **血压记录智能体**：继承0701版本的工具（record_blood_pressure, query_blood_pressure, update_blood_pressure, info）
- **复诊管理智能体**：appointment_booking, query_appointment, update_appointment, set_reminder等（调用Java微服务）
- **医生助手智能体**：query_patient_record, update_patient_record, prescribe_medicine, query_prescription等（调用Java微服务）

### 2.5 系统提示词设计

#### 2.5.1 路由智能体系统提示词

```
你是一个智能路由助手，负责识别用户的真实意图并将任务路由到对应的专门智能体。

你的核心任务是：
1. 识别用户的真实意图（血压记录、复诊管理、医生助手等）
2. 当意图不明确时，友好地引导用户说明
3. 根据意图将任务路由到对应的专门智能体
4. 自动检测用户意图变化并重新路由

支持的意图类型：
- blood_pressure: 用户想要记录、查询或管理血压数据
- appointment: 用户想要预约、查询或管理复诊
- doctor_assistant: 医生需要助手处理咨询、病历、处方等
- unclear: 意图不明确，需要进一步澄清

路由策略：
- 如果意图明确且置信度高（>0.8），直接路由到对应智能体
- 如果意图不明确（置信度<0.8），使用clarify_intent工具生成澄清问题
- 如果用户改变了意图，自动检测并重新路由到新智能体
- 如果用户同时提及多个意图，按优先级处理（优先级：doctor_assistant > appointment > blood_pressure）

记住：始终以用户为中心，提供自然流畅的对话体验。
```

#### 2.5.2 专门智能体系统提示词

每个专门智能体有自己特定的系统提示词：

- **血压记录智能体**：继承0701版本的系统提示词
- **复诊管理智能体**：针对复诊业务的专业提示词
- **医生助手智能体**：针对医生助手业务的专业提示词

### 2.6 实现方案

#### 2.6.1 项目结构

```
0702_ReActAgentMultiAgentRouterTest/
├── 01_backendServer.py          # 后端API服务
├── 02_frontendServer.py          # 前端客户端
├── README.md                     # 项目说明文档
├── utils/
│   ├── __init__.py
│   ├── config.py                # 配置管理
│   ├── llms.py                  # LLM初始化
│   ├── router.py                 # 路由智能体实现（StateGraph）
│   ├── agents/
│   │   ├── __init__.py
│   │   ├── blood_pressure_agent.py    # 血压记录智能体节点
│   │   ├── appointment_agent.py       # 复诊管理智能体节点
│   │   └── doctor_assistant_agent.py  # 医生助手智能体节点
│   └── tools/
│       ├── __init__.py
│       ├── router_tools.py             # 路由智能体工具
│       ├── blood_pressure_tools.py     # 血压记录工具（复用0701）
│       ├── appointment_tools.py        # 复诊管理工具（调用Java微服务）
│       └── doctor_assistant_tools.py   # 医生助手工具（调用Java微服务）
└── logfile/                     # 日志文件目录
```

#### 2.6.2 核心实现流程

1. **用户请求处理**
   ```
   用户请求 → FastAPI接口 → StateGraph Agent.ainvoke()
       ↓
   读取历史对话（从checkpointer）
       ↓
   进入router节点 → 意图识别 → 路由决策
       ↓
   路由到专门智能体节点 → 执行任务
       ↓
   返回到router节点（通过边配置）
       ↓
   保存状态（到checkpointer）
       ↓
   返回结果
   ```

2. **路由节点执行流程**
   ```
   接收用户消息 → identify_intent工具 → 判断意图置信度
   ├─ 高置信度且意图变化 → 设置need_reroute=True → 路由到新智能体
   ├─ 高置信度且意图未变 → 继续当前智能体
   └─ 低置信度 → clarify_intent工具 → 生成澄清问题 → 等待用户回复
   ```

3. **专门智能体节点执行流程**
   ```
   接收路由请求 → 创建或复用智能体实例 → 执行任务 → 返回结果 → 返回到router节点
   ```

#### 2.6.3 会话管理

- **统一会话**：所有智能体使用相同的`session_id`作为`thread_id`
- **状态同步**：路由智能体维护全局状态（RouterState），专门智能体通过消息列表传递上下文
- **自动恢复**：LangGraph自动从checkpointer恢复历史对话和状态

### 2.7 扩展性设计

#### 2.7.1 添加新智能体

1. **创建智能体节点**
   ```python
   # utils/agents/new_agent.py
   async def new_agent_node(state: RouterState) -> RouterState:
       """新智能体节点"""
       messages = state["messages"]
       agent = create_new_agent()
       result = await agent.ainvoke(
           {"messages": messages},
           config={"configurable": {"thread_id": state["session_id"]}}
       )
       state["messages"] = result["messages"]
       return state
   ```

2. **创建工具集**
   ```python
   # utils/tools/new_agent_tools.py
   def create_new_agent_tools(store, user_id):
       # 定义工具（可调用Java微服务）
       return [tool1, tool2, ...]
   ```

3. **注册到路由图**
   ```python
   # utils/router.py
   router_graph.add_node("new_agent", new_agent_node)
   router_graph.add_edge("new_agent", "router")
   # 在route_decision函数中添加路由逻辑
   ```

### 2.8 性能优化

1. **智能意图检查**
   - 如果当前有活跃的智能体，且用户消息很短，可能跳过意图识别
   - 检查意图变化关键词，只对可能改变意图的消息进行识别

2. **异步处理**
   - 路由决策异步执行
   - 专门智能体调用异步执行

3. **缓存机制**
   - 意图识别结果缓存
   - 常用查询结果缓存

### 2.9 错误处理

1. **路由失败**
   - 意图识别失败时，降级到通用智能体或澄清意图
   - 专门智能体不可用时，返回友好的错误提示

2. **上下文丢失**
   - LangGraph自动管理状态，不会丢失上下文
   - 记录智能体切换历史

3. **异常处理**
   - 捕获所有异常并记录日志
   - 返回友好的错误提示给用户

## 三、实施计划

### 3.1 阶段一：基础架构搭建（预计2-3天）

1. 创建项目结构和基础代码
2. 实现StateGraph路由图框架
3. 实现意图识别工具
4. 实现路由决策逻辑

### 3.2 阶段二：专门智能体实现（预计3-4天）

1. 复用0701版本的血压记录智能体
2. 实现复诊管理智能体（基础功能，调用Java微服务）
3. 实现医生助手智能体（基础功能，调用Java微服务）
4. 实现智能体间的切换机制

### 3.3 阶段三：集成和测试（预计2-3天）

1. 集成测试路由功能
2. 端到端测试各个智能体
3. 测试重新路由功能
4. 性能测试和优化
5. 文档完善

### 3.4 阶段四：优化和扩展（持续）

1. 优化意图识别准确率
2. 添加更多专门智能体
3. 优化用户体验
4. 性能持续优化

## 四、风险评估

### 4.1 技术风险

1. **意图识别准确率**
   - 风险：意图识别不准确导致路由错误
   - 缓解：使用置信度阈值，低置信度时进行澄清

2. **性能问题**
   - 风险：每次调用都经过router节点可能影响性能
   - 缓解：使用智能意图检查，避免不必要的意图识别；使用缓存机制

3. **状态管理复杂**
   - 风险：StateGraph的状态管理可能复杂
   - 缓解：清晰的状态定义和节点实现；充分的测试

### 4.2 业务风险

1. **用户体验**
   - 风险：智能体切换可能让用户感到困惑
   - 缓解：无缝切换设计，清晰的提示信息

2. **扩展性**
   - 风险：未来添加新智能体可能影响现有系统
   - 缓解：模块化设计，清晰的接口定义

## 五、总结

本设计方案基于LangGraph StateGraph，实现了一个多智能体路由系统，具有以下特点：

1. **清晰的架构**：路由智能体 + 专门智能体的两层架构，使用StateGraph统一管理
2. **自动重新路由**：每次调用都经过路由节点，自动检测意图变化并重新路由
3. **灵活的扩展**：易于添加新的专门智能体
4. **良好的用户体验**：无缝切换，自然对话
5. **高性能**：智能检查，异步处理，缓存机制

通过这个系统，我们可以：
- 统一管理多个业务智能体
- 提供更好的用户体验
- 支持业务快速扩展
- 保持代码的可维护性

---

*设计方案文档版本：v2.0*  
*设计时间：2025年11月*  
*作者：@舒小龙*  
*相关文档：`V2.0-01-路由流程场景解析.md`、`V2.0-02-重新路由技术细节.md`*

