# 1 概述

## 1.1 系统概述

多智能体路由系统（V2.0）是一个基于LangGraph StateGraph构建的智能对话系统，旨在为用户提供统一的对话入口，自动识别用户意图并路由到对应的专门智能体处理业务需求。

系统核心功能包括：
- **意图识别与路由**：自动识别用户意图，将任务路由到对应的专门智能体
- **血压记录管理**：支持血压数据的记录、查询、更新和统计
- **复诊管理**：支持复诊预约、查询、更新和提醒功能
- **医生助手**：支持医生日常咨询处理、病历管理和处方管理

系统采用LangGraph StateGraph架构，每次调用都经过路由节点，自动检测意图变化并重新路由，确保用户体验的流畅性和系统的可扩展性。

## 1.2 文档概述

本文档是多智能体路由系统的总体设计文档，描述系统的整体架构、技术选型、核心流程和关键设计决策。

相关文档：
- `V2.0-11-路由智能体详细设计.md`：路由智能体的详细设计
- `V2.0-12-血压记录智能体详细设计.md`：血压记录智能体的详细设计
- `V2.0-13-复诊管理智能体详细设计.md`：复诊管理智能体的详细设计
- `V2.0-14-诊断智能体架构设计.md`：诊断智能体系统的详细设计
- `V2.0-14-医生助手智能体详细设计.md`：医生助手智能体设计（已废弃，保留作为历史参考）
- `V2.0-15-前端客户端详细设计.md`：前端客户端的详细设计
- `V2.0-20-健康档案存储详细设计.md`：健康档案存储系统的详细设计
- `V2.0-03-长期记忆设计.md`：长期记忆总体设计
- `V2.0-01-路由流程场景解析.md`：路由流程的场景解析
- `V2.0-02-重新路由技术细节.md`：重新路由的技术细节

## 1.3 基线

- Python 3.10+
- LangGraph 0.2+
- LangChain 0.3+
- FastAPI 0.100+
- PostgreSQL 14+
- Redis 7+

# 2 依赖

| 依赖名称 | 依赖类型 | 描述 |
| ------ | ------ | ------ |
| LangGraph | 框架依赖 | Agent框架，用于构建路由图和专门智能体 |
| LangChain | 框架依赖 | 提供LLM调用和工具支持 |
| FastAPI | 框架依赖 | 后端API服务框架 |
| PostgreSQL | 数据存储 | 短期记忆（checkpointer）和长期记忆（store） |
| Redis | 缓存存储 | 会话状态管理 |
| Java微服务 | 外部服务 | 提供复诊管理等业务功能接口 |
| 向量数据库 | 数据存储 | 存储诊断智能体的知识库（RAG） |

# 3 概要设计(总体设计)

## 3.1 功能概述

系统主要功能模块：

1. **路由智能体（Router Agent）**
   - 意图识别：识别用户真实意图
   - 意图澄清：当意图不明确时，引导用户说明
   - 路由决策：根据意图路由到对应的专门智能体
   - 自动重新路由：检测用户意图变化并重新路由

2. **血压记录智能体（Blood Pressure Agent）**
   - 血压数据记录：引导用户完成血压数据收集
   - 历史查询：查询用户的历史血压记录
   - 数据更新：更新已有血压记录
   - 统计分析：提供血压统计信息

3. **复诊管理智能体（Appointment Agent）**
   - 复诊预约：引导用户完成复诊预约
   - 预约查询：查询用户的复诊预约记录
   - 预约更新：更新预约信息
   - 提醒管理：设置和管理复诊提醒

4. **诊断智能体系统（Diagnosis Agent System）**
   - 内科诊断支持：协助医生进行内科相关疾病的诊断
   - 外科诊断支持：协助医生进行外科相关疾病的诊断
   - 儿科诊断支持：协助医生进行儿科相关疾病的诊断
   - 妇科诊断支持：协助医生进行妇科相关疾病的诊断
   - 心血管科诊断支持：协助医生进行心血管相关疾病的诊断
   - 其他科室诊断支持：支持扩展其他科室的诊断智能体
   - 每个诊断智能体拥有独立的知识库（RAG）和提示词

## 3.2 设计思想

### 3.2.1 关键算法和技术实现或选型

**路由机制**：采用LangGraph StateGraph + 条件路由方案

- **每次调用都经过路由节点**：确保能够检测到用户意图变化
- **状态管理**：使用RouterState统一管理所有状态信息
- **条件路由**：根据意图识别结果，动态路由到对应的专门智能体
- **自动重新路由**：当检测到意图变化时，自动重新路由到新智能体
- **诊断智能体细化**：诊断意图进一步细分为具体科室，路由到对应的专业诊断智能体

**RAG架构**：诊断智能体采用RAG（检索增强生成）架构

- **知识库管理**：每个诊断智能体拥有独立的知识库，存储在向量数据库中
- **检索增强**：通过向量检索获取相关医学知识、病例和指南
- **提示词定制**：每个诊断智能体有专门的系统提示词，定义角色和回答风格
- **模型演进**：前期使用通用模型+RAG，后期可升级为专业医疗模型

**意图识别**：
- 使用LLM进行意图识别，返回意图类型和置信度
- 支持多轮对话澄清意图
- 处理复合意图（用户同时提及多个需求）
- 识别意图变化关键词，优化性能

**会话管理**：
- 使用PostgreSQL作为checkpointer，持久化保存对话历史和状态
- 使用Redis管理会话状态
- 统一的session_id作为thread_id，关联所有智能体的上下文

### 3.2.2 核心数据结构

**RouterState（路由状态）**：
```python
class RouterState(TypedDict):
    messages: List[BaseMessage]  # 消息列表
    current_intent: Optional[str]  # 当前意图：blood_pressure, appointment, diagnosis, unclear
    sub_intent: Optional[str]  # 子意图（如diagnosis下的具体科室）
    current_agent: Optional[str]  # 当前活跃的智能体
    need_reroute: bool  # 是否需要重新路由
    session_id: str  # 会话ID
    user_id: str  # 用户ID
```

**IntentResult（意图识别结果）**：
```python
class IntentResult(BaseModel):
    intent_type: str  # "blood_pressure", "appointment", "diagnosis", "unclear"
    sub_intent: Optional[str]  # 子意图（如diagnosis下的具体科室）
    confidence: float  # 0.0-1.0
    entities: Dict[str, Any]  # 提取的实体信息
    need_clarification: bool  # 是否需要澄清
    reasoning: Optional[str]  # 识别理由
```

## 3.3 基本流程

### 3.3.1 系统用例图

```
用户
  ├─ 记录血压数据
  ├─ 查询血压记录
  ├─ 预约复诊
  ├─ 查询复诊记录
  ├─ 医生咨询
  └─ 管理病历/处方

路由智能体
  ├─ 识别用户意图
  ├─ 澄清意图
  └─ 路由到专门智能体

血压记录智能体
  ├─ 记录血压
  ├─ 查询历史
  └─ 统计数据

复诊管理智能体
  ├─ 预约复诊
  ├─ 查询预约
  └─ 管理提醒

医生助手智能体
  ├─ 处理咨询
  ├─ 管理病历
  └─ 管理处方
```

### 3.3.2 系统流程图

```
用户请求
    ↓
FastAPI接口接收
    ↓
StateGraph Agent.ainvoke()
    ↓
读取历史对话和状态（从checkpointer）
    ↓
进入router节点（入口点）
    ↓
router节点：识别意图，判断是否需要重新路由
    ↓
路由决策：根据意图路由到对应智能体节点
    ├─ blood_pressure → 血压记录智能体
    ├─ appointment → 复诊管理智能体
    ├─ diagnosis → 诊断智能体系统
    │   ├─ internal_medicine_diagnosis → 内科诊断智能体
    │   ├─ surgery_diagnosis → 外科诊断智能体
    │   ├─ pediatrics_diagnosis → 儿科诊断智能体
    │   ├─ gynecology_diagnosis → 妇科诊断智能体
    │   ├─ cardiology_diagnosis → 心血管科诊断智能体
    │   └─ general_diagnosis → 通用诊断智能体（无法确定具体科室）
    └─ unclear → 意图澄清节点
    ↓
执行专门智能体节点
    ↓
返回到router节点（通过边配置）
    ↓
保存新的对话状态（到checkpointer）
    ↓
返回结果给用户
```

### 3.3.3 关键时序图

**正常路由流程**：
```
用户 -> FastAPI: 发送消息
FastAPI -> Router Agent: ainvoke()
Router Agent -> Checkpointer: 读取历史状态
Router Agent -> Intent Tool: 识别意图
Intent Tool -> Router Agent: 返回意图结果
Router Agent -> Route Decision: 路由决策
Route Decision -> Specialized Agent: 路由到专门智能体
Specialized Agent -> Tools: 调用工具
Tools -> Java微服务: HTTP API调用（如需要）
Java微服务 -> Tools: 返回结果
Tools -> Specialized Agent: 返回结果
Specialized Agent -> Router Agent: 返回到路由节点
Router Agent -> Checkpointer: 保存状态
Router Agent -> FastAPI: 返回结果
FastAPI -> 用户: 返回回复
```

**重新路由流程**：
```
用户 -> FastAPI: 发送消息（改变意图）
FastAPI -> Router Agent: ainvoke()
Router Agent -> Checkpointer: 读取历史状态
Router Agent -> Intent Tool: 识别意图（检测到变化）
Intent Tool -> Router Agent: 返回新意图
Router Agent -> Route Decision: 检测到need_reroute=True
Route Decision -> New Specialized Agent: 路由到新智能体
New Specialized Agent -> Router Agent: 执行完成
Router Agent -> Checkpointer: 保存新状态
Router Agent -> FastAPI: 返回结果
```

## 3.4 体系结构

### 3.4.1 层次结构

```
┌─────────────────────────────────────────────────────────┐
│                   用户请求入口                            │
│              (FastAPI Backend Server)                    │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              路由智能体 (Router Agent)                   │
│  基于StateGraph实现，每次调用都经过路由节点               │
│  - 意图识别                                             │
│  - 意图澄清                                             │
│  - 路由决策                                             │
└─────┬───────────┬───────────┬───────────┬──────────────┘
      │           │           │           │
      ▼           ▼           ▼           ▼
┌──────────┐ ┌──────────┐ ┌──────────────────┐ ┌──────────┐
│ 血压记录 │ │ 复诊管理 │ │  诊断智能体系统   │ │ 其他智能体│
│ 智能体   │ │ 智能体   │ │  ├─ 内科诊断      │ │ (可扩展) │
│          │ │          │ │  ├─ 外科诊断      │ │          │
│          │ │          │ │  ├─ 儿科诊断      │ │          │
│          │ │          │ │  └─ 其他科室...   │ │          │
└─────┬────┘ └─────┬────┘ └─────┬──────────────┘ └─────┬────┘
      │           │           │           │
      └───────────┴───────────┴───────────┘
                     │
                     ▼
          ┌──────────────────────┐
          │   返回到路由节点      │
          │  (通过StateGraph边)  │
          └──────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              基础设施层                                   │
│  - PostgreSQL (短期记忆 + 长期记忆)                      │
│  - Redis (会话管理)                                      │
│  - 向量数据库 (RAG知识库)                                │
│  - LangGraph (Agent框架)                                │
│  - Java微服务 (业务功能)                                │
└─────────────────────────────────────────────────────────┘
```

### 3.4.2 功能需求和模块关系

**路由智能体模块**：
- 依赖：LangGraph、LangChain、PostgreSQL、Redis
- 提供：意图识别、路由决策功能
- 使用：专门智能体节点

**血压记录智能体模块**：
- 依赖：路由智能体、PostgreSQL（长期记忆）
- 提供：血压记录、查询、更新、统计功能
- 独立：不依赖Java微服务

**复诊管理智能体模块**：
- 依赖：路由智能体、Java微服务
- 提供：复诊预约、查询、更新、提醒功能
- 通过HTTP API调用Java微服务

**诊断智能体系统模块**：
- 依赖：路由智能体、向量数据库（RAG知识库）
- 提供：各科室诊断支持功能
- 每个诊断智能体拥有独立的知识库和提示词
- 通过RAG检索增强生成诊断建议

### 3.4.3 配置

#### 3.4.3.1 系统级配置

- **数据库配置**：PostgreSQL连接信息、Redis连接信息
- **向量数据库配置**：向量数据库连接信息、知识库路径
- **LLM配置**：API密钥、模型选择、温度参数（支持不同科室使用不同模型）
- **Java微服务配置**：服务地址、认证信息、超时设置

#### 3.4.3.2 应用级配置

- **路由配置**：意图识别置信度阈值、路由决策规则
- **会话配置**：会话TTL、最大对话轮数
- **性能配置**：异步并发数、缓存策略
- **RAG配置**：检索Top-K数量、相似度阈值、知识库版本管理

## 3.5 非功能设计

### 3.5.1 性能及响应时间

**性能要求**：
- 路由决策时间 < 500ms
- 智能体切换时间 < 1s
- 支持并发用户会话（至少100个并发会话）

**优化策略**：
- 使用异步处理，提高并发能力
- 实现智能意图检查，避免不必要的意图识别
- 使用缓存机制，缓存意图识别结果和常用查询结果
- 优化数据库查询，使用索引和连接池

#### 3.5.1.1 缓存设计

- **意图识别结果缓存**：缓存最近N条消息的意图识别结果，避免重复识别
- **查询结果缓存**：缓存用户查询结果，设置合理的TTL
- **会话状态缓存**：Redis缓存会话状态，减少数据库查询

#### 3.5.1.2 分库分表

- 当前阶段：单库单表，PostgreSQL存储checkpoint和长期记忆
- 未来扩展：如果数据量增长，考虑按用户ID分表

#### 3.5.1.3 其他

- 使用连接池管理数据库连接
- 使用异步HTTP客户端调用Java微服务
- 实现请求限流，防止恶意请求

### 3.5.2 安全性说明

#### 3.5.2.1 系统安全

- **API认证**：使用JWT Token进行API认证
- **输入验证**：验证用户输入，防止SQL注入和XSS攻击
- **访问控制**：基于用户ID和角色进行访问控制

#### 3.5.2.2 功能性安全

- **请求大小限制**：限制单次请求消息长度（如最大1000字符）
- **对话轮数限制**：限制单次会话的最大对话轮数（如100轮）
- **工具调用限制**：限制单次对话的工具调用次数

#### 3.5.2.3 数据安全

- **敏感信息**：用户ID、会话ID等敏感信息加密传输
- **数据存储**：敏感数据加密存储
- **日志脱敏**：日志中不记录敏感信息

### 3.5.3 兼容性

- **Python版本**：支持Python 3.10+
- **数据库版本**：支持PostgreSQL 14+
- **Redis版本**：支持Redis 7+
- **API兼容性**：Java微服务API版本兼容性由微服务团队保证

### 3.5.4 可移植性

- 系统设计为可部署到云环境或本地环境
- 配置外部化，支持不同环境的配置
- 不依赖特定的操作系统或硬件

### 3.5.5 资源使用

#### 3.5.5.1 容量规划

**数据库容量**：
- Checkpoint存储：每个会话约10-50KB，1000个活跃会话约50MB
- 长期记忆存储：每个用户约1-10MB，10000个用户约100GB
- 向量数据库：每个科室知识库约1-10GB，7个科室约70GB
- 预估：初期需要120GB存储空间

**Redis容量**：
- 会话状态：每个会话约1-5KB，1000个活跃会话约5MB
- 缓存数据：约100MB
- 预估：初期需要500MB内存

**计算资源**：
- CPU：4核，支持100并发会话
- 内存：8GB，支持100并发会话
- 网络：100Mbps，支持HTTP API调用

### 3.5.6 验证要求

- **单元测试**：覆盖核心功能模块
- **集成测试**：测试路由功能和智能体切换
- **端到端测试**：测试完整业务流程
- **性能测试**：测试并发性能和响应时间

### 3.5.7 部署要求

**部署架构**：
- 后端服务：FastAPI应用，可部署在Docker容器中
- 数据库：PostgreSQL独立部署
- 缓存：Redis独立部署
- 微服务：Java微服务独立部署

**部署方式**：
- 支持Docker容器化部署
- 支持Kubernetes部署
- 支持灰度发布（通过配置开关控制）

**接口说明**：
- 主要接口：FastAPI提供的HTTP API接口
- 调用接口：Java微服务提供的HTTP API接口
- 接口文档：参考详细设计文档中的接口设计章节

# 4 底稿链接

- 设计文档：`V2.0-00-设计方案.md`
- 路由流程解析：`V2.0-01-路由流程场景解析.md`
- 重新路由技术细节：`V2.0-02-重新路由技术细节.md`
- Java微服务集成说明：`900-Java微服务集成说明.md`

