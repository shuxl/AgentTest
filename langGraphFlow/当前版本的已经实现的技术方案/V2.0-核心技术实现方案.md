# V2.0 多智能体路由系统 - 核心技术实现方案

## 一、系统架构概述

### 1.1 整体架构

```
┌─────────────────┐
│  前端客户端      │  (CLI/Web)
│  (02_frontend)  │
└────────┬────────┘
         │ HTTP/JSON
         │
┌────────▼────────┐
│  后端服务        │  (FastAPI)
│  (01_backend)   │
└────────┬────────┘
         │
┌────────▼────────────────────────────────────┐
│        路由智能体图 (LangGraph)              │
│  ┌──────────────────────────────────────┐  │
│  │      Router Node (路由节点)          │  │
│  │  - 意图识别                           │  │
│  │  - 路由决策                           │  │
│  └─────────────┬────────────────────────┘  │
│                │                             │
│    ┌───────────┼───────────┐                │
│    │           │           │                │
│  ┌─▼──┐    ┌──▼──┐    ┌───▼──┐             │
│  │ BP │    │ APT │    │ DOC  │             │
│  │Agent│    │Agent│    │Agent │             │
│  └────┘    └─────┘    └──────┘             │
└────────┬───────────────────────────────────┘
         │
    ┌────┴────────────────────┐
    │                          │
┌───▼────┐            ┌────────▼─────┐
│PostgreSQL│          │   Redis      │
│Database  │          │  (可选)      │
└─────────┘          └───────────────┘
```

### 1.2 核心技术栈

- **框架**：LangGraph（状态图管理）
- **LLM集成**：LangChain
- **状态持久化**：PostgreSQL Checkpointer
- **长期记忆**：PostgreSQL Store
- **数据库**：PostgreSQL（业务数据）
- **缓存**：Redis（可选）
- **后端API**：FastAPI
- **前端客户端**：Python CLI（Rich库）

## 二、路由图设计

### 2.1 图结构

```python
# 节点定义
nodes = {
    "router": router_node,              # 路由节点（入口）
    "clarify_intent": clarify_intent_node,  # 意图澄清节点
    "blood_pressure_agent": blood_pressure_agent_node,  # 血压记录智能体
    "appointment_agent": appointment_agent_node,  # 复诊管理智能体
    "doctor_assistant_agent": placeholder_agent_node  # 医生助手智能体（占位）
}

# 边定义
edges = {
    "router" -> conditional_edges -> {
        "blood_pressure": "blood_pressure_agent",
        "appointment": "appointment_agent",
        "doctor_assistant": "doctor_assistant_agent",
        "unclear": "clarify_intent",
        "__end__": "__end__"
    },
    "blood_pressure_agent" -> "router",  # 回边
    "appointment_agent" -> "router",      # 回边
    "doctor_assistant_agent" -> "router", # 回边
    "clarify_intent" -> "router"         # 回边
}
```

### 2.2 状态流转

```
用户输入
    ↓
router_node (意图识别)
    ↓
route_decision (路由决策)
    ↓
    ├─→ blood_pressure_agent (处理血压相关)
    │       ↓
    │   执行工具调用
    │       ↓
    │   返回router_node (检查是否需要重新路由)
    │
    ├─→ appointment_agent (处理预约相关)
    │       ↓
    │   执行工具调用
    │       ↓
    │   返回router_node
    │
    ├─→ clarify_intent (意图不明确)
    │       ↓
    │   生成澄清问题
    │       ↓
    │   返回router_node (等待用户回复)
    │
    └─→ __end__ (停止执行)
```

## 三、状态管理

### 3.1 RouterState 定义

```python
class RouterState(TypedDict):
    """路由状态数据结构"""
    messages: List[BaseMessage]  # 消息列表（HumanMessage/AIMessage）
    current_intent: Optional[str]  # 当前意图类型
    current_agent: Optional[str]  # 当前活跃的智能体名称
    need_reroute: bool  # 是否需要重新路由
    session_id: str  # 会话ID（对应checkpoint的thread_id）
    user_id: str  # 用户ID
```

### 3.2 状态持久化机制

**Checkpointer（短期记忆）**：
- 使用 PostgreSQL 存储对话状态快照
- 每个 `session_id` 对应一个 `thread_id`
- 自动保存每次节点执行后的状态
- 支持状态恢复和历史消息读取

**实现细节**：
```python
# 初始化checkpointer
checkpointer = AsyncPostgresSaver(pool)
await checkpointer.setup()

# 编译图时绑定checkpointer
graph = router_graph.compile(checkpointer=checkpointer)

# 调用时指定thread_id（对应session_id）
config = {"configurable": {"thread_id": session_id}}
result = await graph.ainvoke(state_input, config=config)
```

**Store（长期记忆）**：
- 使用 PostgreSQL Store 存储用户设置信息
- 支持命名空间隔离（memories、blood_pressure等）
- 结构化数据存储

**实现细节**：
```python
# 初始化store
store = AsyncPostgresStore(pool)
await store.setup()

# 存储用户设置
namespace = ("memories", user_id)
await store.aput(namespace, key, value)

# 查询用户设置
memories = await store.asearch(namespace, query="")
```

## 四、意图识别机制

### 4.1 识别流程

```
用户输入
    ↓
构建提示词（包含对话历史、当前意图）
    ↓
调用LLM（identify_intent工具）
    ↓
解析JSON响应
    ↓
提取IntentResult {
    intent_type: str,
    confidence: float,
    entities: dict,
    need_clarification: bool,
    reasoning: str
}
    ↓
根据置信度判断：
    - confidence >= 0.8 → 直接路由
    - confidence < 0.8 → 需要澄清
```

### 4.2 意图识别提示词

```python
INTENT_IDENTIFICATION_PROMPT = """你是一个智能路由助手，负责识别用户的真实意图。

支持的意图类型：
1. blood_pressure: 用户想要记录、查询或管理血压数据
2. appointment: 用户想要预约、查询或管理复诊
3. doctor_assistant: 医生需要助手处理咨询、病历、处方等
4. unclear: 意图不明确，需要进一步澄清

规则：
- 如果意图明确且置信度>0.8，设置need_clarification=false
- 如果意图不明确（置信度<0.8），设置need_clarification=true
- 如果用户同时提及多个意图，按优先级选择
- 如果用户的消息很短，且当前有活跃的智能体，可能继续当前意图
"""
```

### 4.3 重新路由检测

```python
# 在router_node中检测意图变化
if current_intent != new_intent:
    logger.info(f"检测到意图变化: {current_intent} -> {new_intent}")
    need_reroute = True
    updated_state["need_reroute"] = True
```

## 五、智能体实现

### 5.1 智能体创建模式

所有专门智能体都使用 **ReAct Agent** 模式：

```python
# 使用LangGraph的create_react_agent
agent = create_react_agent(
    model=llm,
    tools=tools,
    checkpointer=checkpointer,
    store=store
)
```

### 5.2 智能体节点工厂函数

使用闭包模式创建节点函数：

```python
def create_blood_pressure_agent_node(pool, checkpointer, store):
    """工厂函数：创建血压记录智能体节点"""
    
    async def blood_pressure_agent_node(state: RouterState) -> RouterState:
        """实际的节点函数"""
        # 1. 从state获取信息
        user_id = state.get("user_id")
        session_id = state.get("session_id")
        messages = state.get("messages", [])
        
        # 2. 创建智能体（使用checkpointer和store）
        agent = await create_blood_pressure_agent(
            llm=get_llm_by_config(),
            pool=pool,
            user_id=user_id,
            checkpointer=checkpointer,
            store=store
        )
        
        # 3. 添加系统提示词
        system_prompt = get_blood_pressure_system_prompt()
        messages_with_system = [SystemMessage(content=system_prompt)] + messages
        
        # 4. 调用智能体
        config = {"configurable": {"thread_id": session_id}}
        result = await agent.ainvoke(
            {"messages": messages_with_system},
            config=config
        )
        
        # 5. 更新state并返回
        updated_state = state.copy()
        updated_state["messages"] = result.get("messages", messages)
        return updated_state
    
    return blood_pressure_agent_node
```

### 5.3 系统提示词管理

每个智能体都有专门的系统提示词：

```python
def get_blood_pressure_system_prompt(current_datetime: str = None) -> str:
    """获取血压记录智能体系统提示词"""
    # 包含：
    # 1. 当前日期时间信息
    # 2. 日期时间处理规则（相对时间解析）
    # 3. 数据验证规则
    # 4. 对话策略
    # 5. 可用工具说明
    return f"""你是一个专业的血压记录助手...
    """
```

## 六、工具实现

### 6.1 工具定义模式

使用 LangChain 的 `@tool` 装饰器：

```python
@tool("record_blood_pressure", description="记录用户的血压数据...")
async def record_blood_pressure(
    systolic: int,
    diastolic: int,
    date_time: Optional[str] = None,
    original_time_description: Optional[str] = None,
    notes: Optional[str] = None
) -> str:
    """工具实现"""
    # 1. 数据验证
    is_valid, validation_msg = validate_blood_pressure(systolic, diastolic)
    if not is_valid:
        return validation_msg
    
    # 2. 时间解析（支持相对时间）
    timestamp, date, _ = await parse_datetime_with_llm(date_time, llm)
    
    # 3. 数据库操作
    async with pool.connection() as conn:
        async with conn.cursor() as cur:
            await cur.execute("INSERT INTO ...", (...))
            result = await cur.fetchone()
    
    # 4. 返回结果
    return f"成功保存血压记录..."
```

### 6.2 时间解析实现

**两阶段解析策略**：

```python
async def parse_datetime_with_llm(date_str: Optional[str], llm=None) -> tuple[str, str, str]:
    """解析日期时间字符串，支持相对时间"""
    
    # 阶段1：标准格式解析（快速路径）
    if re.match(r'^\d{4}-\d{2}-\d{2}', date_str):
        # 尝试标准格式（YYYY-MM-DD, YYYY-MM-DD HH:MM:SS等）
        try:
            dt = datetime.strptime(date_str, "%Y-%m-%d")
            return dt.isoformat(), dt.strftime("%Y-%m-%d"), original_description
        except ValueError:
            pass
    
    # 阶段2：LLM解析（相对时间）
    relative_time_keywords = ["今天", "昨天", "明天", "本周", "上周", "下周", ...]
    if any(keyword in date_str for keyword in relative_time_keywords):
        # 使用LLM解析相对时间
        prompt = ChatPromptTemplate.from_messages([
            ("system", "你是一个时间解析专家..."),
            ("human", "用户描述的时间：{user_time}")
        ])
        chain = prompt | llm
        response = chain.invoke({"user_time": date_str})
        # 解析LLM返回的时间字符串
        dt = datetime.fromisoformat(response.content)
        return dt.isoformat(), dt.strftime("%Y-%m-%d"), original_description
    
    # 默认：使用当前时间
    now = datetime.now()
    return now.isoformat(), now.strftime("%Y-%m-%d"), ""
```

### 6.3 数据库操作模式

**使用连接池 + 异步上下文管理器**：

```python
# 连接池初始化
pool = AsyncConnectionPool(conninfo=db_uri, min_size=2, max_size=10)

# 工具中使用
async with pool.connection() as conn:
    async with conn.cursor() as cur:
        await cur.execute("SELECT ...", (params,))
        rows = await cur.fetchall()
```

**注意**：
- 连接池默认 `autocommit=True`
- 需要事务时，手动设置 `conn.autocommit = False`
- 使用 `async with conn.transaction()` 管理事务

## 七、路由决策逻辑

### 7.1 路由决策函数

```python
def route_decision(state: RouterState) -> Literal["blood_pressure", "appointment", "doctor_assistant", "unclear", "__end__"]:
    """路由决策函数"""
    
    # 1. 检查是否有新的用户消息
    messages = state.get("messages", [])
    if messages:
        last_message = messages[-1]
        # 如果最后一条消息是AI消息，停止执行（防止无限循环）
        if isinstance(last_message, AIMessage):
            return "__end__"
    
    # 2. 根据当前意图路由
    current_intent = state.get("current_intent", "unclear")
    
    if current_intent == "unclear":
        return "unclear"  # 路由到澄清节点
    
    # 3. 其他情况直接返回意图类型（对应智能体节点）
    return current_intent
```

### 7.2 防止无限循环机制

**关键设计**：

1. **检查最后一条消息类型**：
   ```python
   if isinstance(last_message, AIMessage):
       return "__end__"  # 停止执行
   ```

2. **路由节点检查**：
   ```python
   # 在router_node中
   if isinstance(last_message, AIMessage):
       logger.info("最后一条消息是AI消息，没有新的用户消息，停止路由执行")
       return state
   ```

3. **设置递归限制**：
   ```python
   config = {
       "configurable": {
           "thread_id": session_id,
           "recursion_limit": 50  # 防止无限循环
       }
   }
   ```

## 八、数据库设计

### 8.1 业务表结构

**blood_pressure_records 表**：
```sql
CREATE TABLE blood_pressure_records (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    systolic INTEGER NOT NULL,
    diastolic INTEGER NOT NULL,
    measurement_time TIMESTAMP NOT NULL,
    original_time_description TEXT,  -- 原始时间描述
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**appointments 表**：
```sql
CREATE TABLE appointments (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    department VARCHAR(255) NOT NULL,
    doctor_id VARCHAR(255),
    doctor_name VARCHAR(255),
    appointment_date TIMESTAMP NOT NULL,
    status VARCHAR(50) DEFAULT 'pending',
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 8.2 LangGraph管理表

**Checkpointer表**（自动创建）：
- `checkpoints`：状态快照
- `checkpoint_writes`：写入记录
- `checkpoint_blobs`：数据块

**Store表**（自动创建）：
- `kv_store`：键值存储
- `vector_store`：向量存储（可选）

## 九、API设计

### 9.1 后端服务架构

```python
# FastAPI应用
app = FastAPI(lifespan=lifespan)

# 生命周期管理
@asynccontextmanager
async def lifespan(app: FastAPI):
    # 初始化阶段
    app.state.pool = await db_pool.create_pool()
    app.state.checkpointer = AsyncPostgresSaver(app.state.pool)
    app.state.store = AsyncPostgresStore(app.state.pool)
    app.state.router_agent = await create_router_agent(...)
    
    yield
    
    # 清理阶段
    await app.state.redis_manager.close()
    await app.state.pool.close()
```

### 9.2 对话接口实现

```python
@app.post("/api/chat", response_model=ChatResponse)
async def chat(request: ChatRequest):
    """对话接口"""
    
    # 1. 构造输入消息
    messages = [HumanMessage(content=request.message)]
    
    # 2. 构造配置（使用session_id作为thread_id）
    config = {
        "configurable": {
            "thread_id": request.session_id,
            "recursion_limit": 50
        }
    }
    
    # 3. 构造状态
    state_input = {
        "messages": messages,
        "user_id": request.user_id,
        "session_id": request.session_id,
        "current_intent": None,
        "current_agent": None,
        "need_reroute": False
    }
    
    # 4. 调用路由智能体（LangGraph会自动从checkpointer读取历史）
    result = await router_agent.ainvoke(state_input, config=config)
    
    # 5. 提取最后一条AI消息作为回复
    messages_result = result.get("messages", [])
    response_text = ""
    for msg in reversed(messages_result):
        if isinstance(msg, AIMessage):
            response_text = msg.content
            break
    
    # 6. 返回响应
    return ChatResponse(
        response=response_text,
        current_intent=result.get("current_intent", "unclear"),
        current_agent=result.get("current_agent")
    )
```

## 十、错误处理机制

### 10.1 异常处理策略

**工具层**：
```python
@tool("record_blood_pressure")
async def record_blood_pressure(...):
    try:
        # 工具逻辑
        ...
    except Exception as e:
        logger.error(f"保存血压记录失败: {str(e)}")
        return f"保存血压记录时发生错误: {str(e)}"
```

**节点层**：
```python
async def blood_pressure_agent_node(state: RouterState) -> RouterState:
    try:
        # 节点逻辑
        ...
    except Exception as e:
        logger.error(f"血压记录智能体节点执行失败: {str(e)}")
        import traceback
        traceback.print_exc()
        return state  # 返回未更新的状态
```

**API层**：
```python
@app.post("/api/chat")
async def chat(request: ChatRequest):
    try:
        # API逻辑
        ...
    except Exception as e:
        logger.error(f"处理对话请求时出错: {str(e)}")
        raise HTTPException(status_code=500, detail=f"处理请求时出错: {str(e)}")
```

### 10.2 数据验证

**血压数据验证**：
```python
def validate_blood_pressure(systolic: int, diastolic: int) -> tuple[bool, str]:
    # 范围检查
    if not (50 <= systolic <= 300):
        return False, "收缩压超出合理范围"
    
    if not (30 <= diastolic <= 200):
        return False, "舒张压超出合理范围"
    
    # 逻辑检查
    if systolic <= diastolic:
        return False, "收缩压必须大于舒张压"
    
    return True, ""
```

**预约时间验证**：
```python
def validate_appointment_date(appointment_date: datetime) -> tuple[bool, str]:
    now = datetime.now()
    if appointment_date < now:
        return False, "预约时间不能是过去时间"
    return True, ""
```

## 十一、性能优化

### 11.1 连接池管理

```python
# 数据库连接池
pool = AsyncConnectionPool(
    conninfo=db_uri,
    min_size=2,      # 最小连接数
    max_size=10,      # 最大连接数
    open=True         # 立即打开连接池
)
```

### 11.2 缓存策略（可选）

```python
# Redis缓存（可选）
redis_manager = get_redis_manager()
# 可用于缓存：
# - 用户设置信息
# - 频繁查询的数据
# - LLM响应（如果支持）
```

### 11.3 异步处理

- 所有数据库操作使用异步接口
- 工具函数使用 `async def`
- 使用 `await` 等待异步操作完成

## 十二、日志和监控

### 12.1 日志配置

```python
# 统一日志配置
setup_logging()

# 日志级别
- DEBUG: 详细调试信息
- INFO: 正常操作信息
- WARNING: 警告信息
- ERROR: 错误信息
```

### 12.2 关键日志点

- 意图识别结果
- 路由决策
- 工具调用
- 数据库操作
- 错误异常

## 十三、部署和运维

### 13.1 环境配置

```bash
# 环境变量
export DB_URI="postgresql://user:password@localhost:5432/dbname"
export REDIS_HOST="localhost"
export REDIS_PORT="6379"
export DEEPSEEK_API_KEY="your-api-key"
export LLM_TYPE="deepseek-chat"
```

### 13.2 启动服务

```bash
# 启动后端服务
python 01_backendServer.py

# 启动前端客户端
python 02_frontendServer.py
```

### 13.3 数据库初始化

```bash
# 创建业务表
python create_blood_pressure_table.py
python create_appointment_table.py

# LangGraph表会自动创建（首次运行时）
```

## 十四、总结

### 14.1 核心技术要点

1. **LangGraph状态图**：管理多智能体路由流程
2. **PostgreSQL Checkpointer**：持久化对话状态
3. **PostgreSQL Store**：存储长期记忆
4. **ReAct Agent模式**：每个专门智能体都是ReAct Agent
5. **工具系统**：使用LangChain工具系统
6. **异步处理**：全异步架构，提高性能

### 14.2 设计模式

1. **工厂函数模式**：创建智能体节点
2. **闭包模式**：捕获外部依赖（pool、checkpointer、store）
3. **状态机模式**：路由图状态流转
4. **策略模式**：不同的时间解析策略

### 14.3 关键技术决策

1. **状态持久化**：选择PostgreSQL而非内存，支持会话恢复
2. **时间解析**：两阶段解析（标准格式 + LLM解析）
3. **路由机制**：每次用户输入都经过router节点，支持动态路由
4. **错误处理**：分层错误处理，保证系统稳定性

---

**文档版本**：V2.0  
**最后更新**：2024-01-XX  
**维护者**：开发团队

